<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>22-51单片机学习</title>
      <link href="/2023/03/30/12-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%20(2)/"/>
      <url>/2023/03/30/12-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%20(2)/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>17-AcWing算法基础课</title>
      <link href="/2022/04/09/06-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
      <url>/2022/04/09/06-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-803-区间合并"><a href="#AcWing-803-区间合并" class="headerlink" title="AcWing 803. 区间合并"></a>AcWing 803. 区间合并</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-suanfa/2022-04-09_09-35-23.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">-2e9</span>,r = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:segs)</span><br><span class="line">        <span class="keyword">if</span>(r &lt; item.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">            l = item.first;</span><br><span class="line">            r = item.second; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r = <span class="built_in">max</span>(r,item.second);</span><br><span class="line">    <span class="keyword">if</span>(l != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;l,r&#125;); <span class="comment">//怎么理解这个地方很关键,假设区间一直都在合并,那么最后这个区间就不会被push_back,那么就错了,</span></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大佬们的评论"><a href="#大佬们的评论" class="headerlink" title="大佬们的评论"></a>大佬们的评论</h2><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-suanfa/2022-04-09_10-37-09.png" alt="2022-04-09_10-37-09"></p><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-suanfa/2022-04-09_10-36-35.png" alt="2022-04-09_10-36-35"><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-suanfa/2022-04-09_10-36-50.png" alt="2022-04-09_10-36-50"></p><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-suanfa/2022-04-09_10-37-23.png" alt="2022-04-09_10-37-23"></p><h2 id="自己模仿大佬重写了一下"><a href="#自己模仿大佬重写了一下" class="headerlink" title="自己模仿大佬重写了一下"></a>自己模仿大佬重写了一下</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; res;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;res)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; temp;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">-2e9</span>,e = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e &lt; item.first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f!=<span class="number">-2e9</span>) temp.<span class="built_in">push_back</span>(&#123;f,e&#125;);</span><br><span class="line">            f = item.first;</span><br><span class="line">            e = item.second;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> e = <span class="built_in">max</span>(e,item.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f!=<span class="number">-2e9</span>) temp.<span class="built_in">push_back</span>(&#123;f,e&#125;);</span><br><span class="line">    res = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">merge</span>(res);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果说还有什么不理解的地方就是这个,if(f! = -2e9),为什么是判断左边,不判断右边,这里可以那样理解,因为f和e是同步变化的,但是e在下一个else里面可以会被改变,所以要判断左边(其实自己写的这些理解别人一般看不懂,毕竟是自己的笔记,自己看懂就行了)</p></blockquote><h1 id="快速排序模板"><a href="#快速排序模板" class="headerlink" title="快速排序模板"></a>快速排序模板</h1><h2 id="快排思想"><a href="#快排思想" class="headerlink" title="快排思想"></a>快排思想</h2><p>快排是基于分治思想来思考的,步骤如下</p><ol><li>确定分界点q[l],q[(l+r)/2],q[r]随机</li><li>调整区间,小于等于x的放左边,大于等于x的放右边</li><li>递归处理</li></ol><blockquote><p>关于这个调整区间,其实有比较简单的方法,比较暴力,就是单独开两个数组,一个数组存小于等于x的值,一个数组存大于等于x的值,比较优美的方法是双指针来解决这道题,就是左神讲的那样一直merge</p></blockquote><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-suanfa/2022-04-09_16-20-45.png" alt="2022-04-09_16-20-45"></p><blockquote><p>疑惑点1:if(l &gt;= r)这里的条件可以换成l == r吗,是可以的</p></blockquote><h1 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a>归并排序模板</h1><h1 id="二分法模板"><a href="#二分法模板" class="headerlink" title="二分法模板"></a>二分法模板</h1><p>红色部分相当于不满足条件的那一部分,绿色为满足条件的那一部分,我要找的点位于这两个区间的交界处,check函数就是检查这个点位于哪个区间,假设为true就是位于绿色区间,假设为false就是红色区间,第一个mid是指以红色区间的右边为分界点,第二个mid是指以绿色的左边为分界点,</p><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-suanfa/2022-04-09_17-23-37.png" alt="2022-04-09_17-23-37"></p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="单源最短路问题"><a href="#单源最短路问题" class="headerlink" title="单源最短路问题"></a>单源最短路问题</h2><h3 id="朴素版的dijkstra算法"><a href="#朴素版的dijkstra算法" class="headerlink" title="朴素版的dijkstra算法"></a>朴素版的dijkstra算法</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 $-1$。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 $n$ 和 $m$。</p><p>接下来 $m$ 行每行包含三个整数 $x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p><p>如果路径不存在，则输出 $-1$。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1 \le n \le 500$,<br>$1 \le m \le 10^5$,<br>图中涉及边长均不超过10000。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 1</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> acwing </tag>
            
            <tag> y总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-Linux软件安装</title>
      <link href="/2022/04/02/10-Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2022/04/02/10-Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="配置java环境"><a href="#配置java环境" class="headerlink" title="配置java环境"></a>配置java环境</h1><ol><li><p>配置环境变量，vi /etc/profile 文件，在文件末尾追加如下内容。并保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8.0_101</span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="built_in">export</span> CLASSPATH</span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效<code> source /ect/profile</code></p></li><li><p>输入java -version 和javac -version如果出现对应的jdk版本，则表明安装成功。</p></li></ol><h1 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.75.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv apache-tomcat-8.5.75 /usr/<span class="built_in">local</span>/Tomcat8.5</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/Tomcat8.5/bin/*.sh</span><br></pre></td></tr></table></figure><p>修改端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/Connector port=&quot;8080&quot;/Connector port=&quot;80&quot;/&#x27;</span> /usr/<span class="built_in">local</span>/Tomcat8.5/conf/server.xml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/Tomcat8.5/bin/./startup.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20-毕业设计</title>
      <link href="/2022/04/01/09-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/04/01/09-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="百度地图api"><a href="#百度地图api" class="headerlink" title="百度地图api"></a>百度地图api</h1><p>2022-04-01通宵学这个api,我要实现的是电子打卡.需要的功能是普通ip定位和地理围栏功能</p><p>自己本来打算用html5 定位,可以精确至10米,但是需要html5授权,学生端可以选择拒绝,但是采用ip定位,在打开网页的一瞬间你的ip地址就会被request请求发送到后台,然后就可以分析学生是不是处于中高风险地区,虽然这个request只能定位到县级单位,但是对于知道学生在不在中高风险地区还是绰绰有余的</p><p>如果想玩html5定位的推荐一个GitHub小程序seeker</p><p>刚刚我尝试去分析seeker的源码,发现网上就有这样一段代码,需要用户的授权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">使用navigator.geolocation对象来获取位置信息，geolocation对象包含一系列相关位置操作方法</span><br><span class="line">需要选择IE9及以上的浏览器</span><br><span class="line">一般流程：</span><br><span class="line">    1.用户从浏览器打开位置感应应用程序</span><br><span class="line">    2.程序执行，geolocation对象获取位置信息，此时浏览器要求用户授权同意才可以获得信息</span><br><span class="line">    3.浏览器内部通过数据源获取信息</span><br><span class="line">    4.浏览器将获取的信息发送给受信任的外部定位服务，返回位置信息到geolocation应用程序</span><br><span class="line">操作方法：</span><br><span class="line">    navigator.geolocation包含三个方法：</span><br><span class="line">    获取当前地址信息（请求一次）</span><br><span class="line">    getCurrentPosition(successCallback, errorCallback, positionOptions)</span><br><span class="line">    监视当前地理位置（请求多次）</span><br><span class="line">    watchPosition(successCallback, errorCallback, positionOptions)</span><br><span class="line">    清除监视功能</span><br><span class="line">    clearWatch(watchId)</span><br><span class="line"></span><br><span class="line">getCurrentPosition(successCallback, errorCallback, positionOptions)</span><br><span class="line">    successCallback 回调函数接受一个参数：位置对象。这个对象包含坐标(coords属性)和一个获取位置数据时的时间戳</span><br><span class="line">        coords属性：</span><br><span class="line">            coords.latitude  十进制数的纬度</span><br><span class="line">            coords.longitude  十进制数的经度</span><br><span class="line">            coords.accuracy  所提供的以米为单位的经度和纬度估计的精确度</span><br><span class="line">            coords.altitude  海拔，海平面以上以米计</span><br><span class="line">            coords.altitudeAccuracy  所提供的以米为单位的高度估计的精确度</span><br><span class="line">            coords.heading  宿主设备当前移动的角度方向，相对于正北方向顺时针计算</span><br><span class="line">            coords.speed  以米每秒为单位的设备的当前对地速度</span><br><span class="line">        timestamp  响应的日期/时间</span><br><span class="line">    errorCallback 接受错误对象作为参数，包含code属性、message信息</span><br><span class="line">        code属性：</span><br><span class="line">            1. 当属性值为1时，用户不允许地理定位（拒绝授权），“Permission denied”。</span><br><span class="line">            2. 当属性值为2时，无法获取当前位置，“Position unavailable”。</span><br><span class="line">            3. 当属性值为3时，操作超时，“Timeout”</span><br><span class="line">        message属性：属性值是一个字符串，包含了错误信息，这个错误信息在我们开发和调试时非常有用</span><br><span class="line">    positionOptions 是一个可选属性的列表，说明如下：</span><br><span class="line">        enableHighAccuracy : 启用高精确度模式，这个参数通知浏览器启用HTML5</span><br><span class="line">        Geolocation : 服务的高精确度模式，默认值为false</span><br><span class="line">        timeout ： 超时限制（单位为毫秒）。如果在该时间内为获取到地理位置信息，则返回错误</span><br><span class="line">        maximumAge ： 表示浏览器重新计算位置的时间间隔，单位为ms，默认值为零，这意味着浏览器每次请求都必须重新计算位置</span><br><span class="line">watchPosition(successCallback, errorCallback, positionOptions)</span><br><span class="line">    使用该方法可以定期获取用户地理位置信息，该方法与getCurrentPosition方法类似，这里调用会返回一个数字，</span><br><span class="line">    该数字与setInterval方法的返回值用法类似，可以被clearWatch方法使用，以停止对当前地理位置信息的监视。</span><br><span class="line">clearWatch(watchId)</span><br><span class="line">    如果应用程序不需要再接受watchPosition的持续位置更新，则只需要调用clearWatch()函数,watchId是watchPosition函数的返回值</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span>点击按钮获取您当前坐标：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;getLocation()&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (navigator.geolocation) &#123;</span></span><br><span class="line"><span class="javascript">                navigator.geolocation.getCurrentPosition(showPosition, showError);</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                x.innerHTML = <span class="string">&quot;该浏览器不支持获取地理位置。&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            x.innerHTML = <span class="string">&quot;纬度: &quot;</span> + position.coords.latitude +</span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;&lt;br&gt;经度: &quot;</span> + position.coords.longitude +</span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;&lt;br&gt;位置精度: &quot;</span> + position.coords.accuracy +</span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;&lt;br&gt;海拔: &quot;</span> + position.coords.altitude +</span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;&lt;br&gt;位置的海拔精度: &quot;</span> + position.coords.altitudeAccuracy +</span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;&lt;br&gt;方向: &quot;</span> + position.coords.heading +</span></span><br><span class="line"><span class="javascript">                <span class="string">&quot;&lt;br&gt;速度: &quot;</span> + position.coords.speed;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">showError</span>(<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (error.code) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> error.PERMISSION_DENIED:</span></span><br><span class="line"><span class="javascript">                    x.innerHTML = <span class="string">&quot;用户拒绝对获取地理位置的请求。&quot;</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> error.POSITION_UNAVAILABLE:</span></span><br><span class="line"><span class="javascript">                    x.innerHTML = <span class="string">&quot;位置信息是不可用的。&quot;</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> error.TIMEOUT:</span></span><br><span class="line"><span class="javascript">                    x.innerHTML = <span class="string">&quot;请求用户地理位置超时。&quot;</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> error.UNKNOWN_ERROR:</span></span><br><span class="line"><span class="javascript">                    x.innerHTML = <span class="string">&quot;未知错误。&quot;</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前后端分离需要解决跨域问题</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> ssm </category>
          
          <category> 前后端分离 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
            <tag> ssm </tag>
            
            <tag> vue </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-我的博客</title>
      <link href="/2022/03/28/12-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%20(1)/"/>
      <url>/2022/03/28/12-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%20(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="Butterfly主题"><a href="#Butterfly主题" class="headerlink" title="Butterfly主题"></a>Butterfly主题</h1><h2 id="配置说说页面步骤"><a href="#配置说说页面步骤" class="headerlink" title="配置说说页面步骤"></a>配置说说页面步骤</h2><ol><li><p>前往 <a href="https://leancloud.app/">LeanCloud 国际版</a><a href="https://leancloud.app/"> </a>，注册账号。</p></li><li><p>注册完成之后根据 LeanCloud 的提示绑定手机号和邮箱。</p></li><li><p>绑定完成之后点击<code>创建应用</code>，应用名称随意，接着在<code>结构化数据</code>中创建 <code>class</code>，命名为 <code>shuoshuo</code>。</p></li><li><p>在你新建的应用中找到<code>结构化数据</code>下的<code>用户</code>。点击<code>添加用户</code>，输入想用的用户名及密码。</p></li><li><p>回到<code>结构化数据</code>中，点击 <code>class</code> 下的 <code>shuoshuo</code>。找到权限，在 <code>Class 访问权限</code>中将 <code>add_fields</code> 以及 <code>create</code> 权限设置为指定用户，输入你刚才输入的用户名会自动匹配。为了安全起见，将 <code>delete</code> 和 <code>update</code> 也设置为跟它们一样的权限。</p></li><li><p>然后新建一个名为<code>atComment</code>的class，权限什么的使用默认的即可。</p></li><li><p>点击 <code>class</code> 下的 <code>_User</code> 添加列，列名称为 <code>img</code>，默认值填上你这个账号想要用的发布说说的头像url，这一项不进行配置，说说头像会显示为默认头像 —— Artitalk 的 logo。</p></li><li><p>在最菜单栏中找到设置-&gt; 应用 keys，记下来 <code>AppID</code> 和 <code>AppKey</code> ，一会会用。</p></li><li><p>最后将 <code>_User</code> 中的权限全部调为指定用户，或者数据创建者，为了保证不被篡改用户数据以达到强制发布说说。</p></li><li><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/hexo/2022-03-28_12-32-55.png"></p><p>然后hexo new shuoshuo就会出现这个index.md</p></li><li><p>然后在index.md里面添加代码,然后是typora来编辑,一定要记得切换到源代码模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用 artitalk --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/artitalk&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 存放说说的容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;artitalk_main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Artitalk(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// Your LeanCloud appId</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">appKey</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">// Your LeanCloud appKey</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">serverURL</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">//因为自己的leancloud注册的是华北的账号,所以必须要填这个serverURL</span></span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个serverURL在这里找<img src="https://secqin.oss-cn-beijing.aliyuncs.com/hexo/2022-03-28_12-37-10.png" alt="2022-03-28_12-37-10"></p></li><li><p>别忘了配置网站白名单,在安全中心里面配置</p><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/hexo/2022-03-28_12-40-12.png" alt="2022-03-28_12-40-12"></p></li></ol><p><a href="https://artitalk.js.org/settings.html">artitalk完整配置项</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>19-Acwing-PAT甲级辅导课</title>
      <link href="/2022/03/25/08-Acwing-PAT%E7%94%B2%E7%BA%A7%E8%BE%85%E5%AF%BC%E8%AF%BE/"/>
      <url>/2022/03/25/08-Acwing-PAT%E7%94%B2%E7%BA%A7%E8%BE%85%E5%AF%BC%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="1473-A-B-格式"><a href="#1473-A-B-格式" class="headerlink" title="1473. A + B 格式"></a>1473. A + B 格式</h2><p>在处理字符串时,一般 就string(80%)和char[]数组(20%)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">int</span> c = a+b;</span><br><span class="line">    string num = <span class="built_in">to_string</span>(c);<span class="comment">//把数字(浮点数和整数都可以)转换为字符串</span></span><br><span class="line">    string res; <span class="comment">//</span></span><br><span class="line">    <span class="comment">//加入逗号,从后往前数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =num.<span class="built_in">size</span>() <span class="number">-1</span>,j=<span class="number">0</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        res = num[i] + res; <span class="comment">//num[i]确实是一直往前放</span></span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(j % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; num[i<span class="number">-1</span>]!=<span class="string">&#x27;-&#x27;</span>&amp;&amp;i) res = <span class="string">&#x27;,&#x27;</span>+res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小结:</p><p>学到了to_string函数的用法,还有for里面的起始条件可以放多个(i=0)</p><p>多用库函数</p></blockquote><p>自己写的时候也是漏洞百出,</p><ol><li>像我直接res += num[i] ;这个表达形式相当于res = res +num[i];这就大错特错了,<mark class="hl-label red">以后遇到字符串的拼接,不建议使用+=或者使用-=</mark> </li><li>数字转化为字符串了以后注意数字的高位对应的是字符串里面的index低位</li><li>那个if条件-<mark class="hl-label red">可能会出现(,117)(-,117)这两种情况</mark> 所以i为0的时候不加,i-1的位置为-的时候不加</li></ol><h2 id="1477-拼写正确"><a href="#1477-拼写正确" class="headerlink" title="1477. 拼写正确"></a>1477. 拼写正确</h2><p>自己的第一代代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        b = b+a%<span class="number">10</span>;</span><br><span class="line">        a = a/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string num = <span class="built_in">to_string</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;num.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(num[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:cout&lt;&lt;<span class="string">&quot;zero &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:cout&lt;&lt;<span class="string">&quot;one &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:cout&lt;&lt;<span class="string">&quot;two &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:cout&lt;&lt;<span class="string">&quot;three &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:cout&lt;&lt;<span class="string">&quot;four &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:cout&lt;&lt;<span class="string">&quot;five &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:cout&lt;&lt;<span class="string">&quot;six &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:cout&lt;&lt;<span class="string">&quot;seven &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:cout&lt;&lt;<span class="string">&quot;eight &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:cout&lt;&lt;<span class="string">&quot;nine &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果出错了</p><p>因为数据范围为:0≤<em>N</em>≤10^100;long long int 都不行,还是听y总讲完</p><p>我的第二代代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        sum += n[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum - <span class="number">48</span>*n.<span class="built_in">size</span>();</span><br><span class="line">    string num = <span class="built_in">to_string</span>(sum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;num.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(num[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:cout&lt;&lt;<span class="string">&quot;zero &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:cout&lt;&lt;<span class="string">&quot;one &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:cout&lt;&lt;<span class="string">&quot;two &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:cout&lt;&lt;<span class="string">&quot;three &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:cout&lt;&lt;<span class="string">&quot;four &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:cout&lt;&lt;<span class="string">&quot;five &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:cout&lt;&lt;<span class="string">&quot;six &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>:cout&lt;&lt;<span class="string">&quot;seven &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:cout&lt;&lt;<span class="string">&quot;eight &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;9&#x27;</span>:cout&lt;&lt;<span class="string">&quot;nine &quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以ac</p><blockquote><p>48可以换成 ‘0’</p></blockquote><p>y总的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:n) s+=c -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">string str = <span class="built_in">to_string</span>(s);</span><br><span class="line"><span class="keyword">char</span> word[<span class="number">10</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,</span><br><span class="line">    <span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c : str) cout &lt;&lt;word[c - <span class="string">&#x27;0&#x27;</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><p>最后的那个输出y总又改了一下,因为pat判题很严格,最后一个不允许又空格,可以把第一个正常输出,然后后面的数字第一个为空格,第二个为数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; word[str[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;str.<span class="built_in">size</span>();i++) cout &lt;&lt;<span class="string">&#x27; &#x27;</span> &lt;&lt;word[str[i]-<span class="string">&#x27;0&#x27;</span>];</span><br></pre></td></tr></table></figure><blockquote><p>总结:在c++中双引号和单引号是由区别的,单引号引字符串,打印的直接是ascii码</p></blockquote><h2 id="1478-签到与签出"><a href="#1478-签到与签出" class="headerlink" title="1478. 签到与签出"></a>1478. 签到与签出</h2><p>自己的第一代代码,自己想到了是字典序比较,但是关于输入自己没有掌握</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a[<span class="number">11</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        cin &gt;&gt; a[i][<span class="number">0</span>] &gt;&gt; a[i][<span class="number">1</span>] &gt;&gt; a[i][<span class="number">2</span>];</span><br><span class="line">    string time1 = a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    string time2 = a[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> flag1,flag2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]&lt;time1)&#123;</span><br><span class="line">            time1 = a[i][<span class="number">1</span>];</span><br><span class="line">            flag1 = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">2</span>]&gt;time2)&#123;</span><br><span class="line">            time2 = a[i][<span class="number">2</span>];</span><br><span class="line">            flag2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[flag1][<span class="number">0</span>] &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;a[flag2][<span class="number">0</span>] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>发现没有输出,问题在于没有string二维数组,y总代码的思路还是强的一批</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string open_id,open_time;</span><br><span class="line">    string close_id,close_time;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string id,ot,ct;</span><br><span class="line">        cin &gt;&gt; id &gt;&gt; ot &gt;&gt; ct;</span><br><span class="line">        <span class="keyword">if</span>(!i || open_time&gt;ot)&#123;</span><br><span class="line">            open_id = id;</span><br><span class="line">            open_time = ot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!i || ct&gt;close_time)&#123;</span><br><span class="line">            close_id = id;</span><br><span class="line">            close_time = ct;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; open_id &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;close_id &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的这个if耐人寻味,平时我都是在外面给比较的最大值或者最小值赋初值,这里直接一个if全包了,何其的叼!!!<mark class="hl-label green">y总yyds!!!</mark> </p><p>直接一个for里面解决</p></blockquote><p>pat的题目细节真多</p><h2 id="1519-密码"><a href="#1519-密码" class="headerlink" title="1519. 密码"></a>1519. 密码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string n[<span class="number">1000</span>],m[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string sub;</span><br><span class="line">        string name,pwd;</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; pwd;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:pwd)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) sub = sub + <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) sub = sub +<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;O&#x27;</span>) sub = sub +<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;l&#x27;</span>) sub = sub +<span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> sub = sub + c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sub != pwd)&#123;</span><br><span class="line">            n[flag] = name;</span><br><span class="line">            m[flag] = s;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;flag;i++)&#123;</span><br><span class="line">        cout &lt;&lt; n[i] &lt;&lt; m[i] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我感觉我这代码没有问题,但是就是输出不了结果,那个标准题解和我的差别在也没有把那个替换部分给封装成为函数</p><mark class="hl-label red">发现是n没有输入</mark>  ,细节呀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string n[<span class="number">1000</span>],m[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string sub;</span><br><span class="line">        string name,pwd;</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; pwd;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:pwd)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>) sub = sub + <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) sub = sub +<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;O&#x27;</span>) sub = sub +<span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;l&#x27;</span>) sub = sub +<span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> sub = sub + c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sub != pwd)&#123;</span><br><span class="line">            n[flag] = name;</span><br><span class="line">            m[flag] = sub;</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;There is &quot;</span>&lt;&lt;N&lt;&lt;<span class="string">&quot; account and no account is modified&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt;<span class="string">&quot;There are &quot;</span>&lt;&lt;N&lt;&lt;<span class="string">&quot; accounts and no account is modified&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; flag &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;flag;i++)&#123;</span><br><span class="line">        cout &lt;&lt; n[i] &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; m[i] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1520-男孩-vs-女孩"><a href="#1520-男孩-vs-女孩" class="headerlink" title="1520. 男孩 vs 女孩"></a>1520. 男孩 vs 女孩</h2><p>自己的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> flag1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flag2 = <span class="number">0</span>;</span><br><span class="line">    string man,man_id;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    string woman,woman_id;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        string name,sex,id;</span><br><span class="line">        <span class="keyword">int</span> grade;</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; sex &gt;&gt; id &gt;&gt; grade;</span><br><span class="line">        <span class="keyword">if</span>((!flag1 || max&lt;grade) &amp;&amp; sex == <span class="string">&quot;F&quot;</span>)&#123; <span class="comment">//这里这个赋初值的方法我改自y总的方法,这里就不能用!i来判断了,因为有两个不同的需要赋初值</span></span><br><span class="line">            max = grade;</span><br><span class="line">            flag1 = <span class="number">1</span>;</span><br><span class="line">            woman = name;</span><br><span class="line">            woman_id = id;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((!flag2 || min &gt;grade) &amp;&amp; sex == <span class="string">&quot;M&quot;</span> )&#123;</span><br><span class="line">            min = grade;</span><br><span class="line">            flag2 = <span class="number">1</span>;</span><br><span class="line">            man = name;</span><br><span class="line">            man_id = id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag1 == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Absent&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; man &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;man_id &lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NA&quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag2 == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; woman &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; woman_id &lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;Absent&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NA&quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; woman &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; woman_id &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; man &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;man_id &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt;  max -min&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这题没有遇到什么瓶颈,都是前面y总的套路,y总yyds</p></blockquote><h2 id="1534-字符串减法"><a href="#1534-字符串减法" class="headerlink" title="1534. 字符串减法"></a>1534. 字符串减法</h2><p>自己的第一个版本的代码:       </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    getline(cin,s1);</span><br><span class="line">    getline(cin,s2);</span><br><span class="line">    <span class="keyword">for</span>(auto c:s2)&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(auto d:s1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d == c)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res = res + d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s1 = res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己的这个代码能ac很多情况,但是这道题给的数据范围是:<mark class="hl-label 10^4">两个给定字符串的长度都不超过</mark> </p><p>报错了: Time Limit Exceeded 超时了,难道要用char数组?可以试一下给s2判重一下,毕竟只有256种字符</p><p>看别人题解的题解是采用<mark class="hl-label green">桶排序</mark> </p><p>自己的第二个版本的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1,s2;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s1);</span><br><span class="line">    <span class="built_in">getline</span>(cin,s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c:s2)&#123;</span><br><span class="line">        a[c] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:s1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[c] ==<span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己改进了一下题解的代码,比题解更短了</p><p>这里的判重可以封装成一个函数,y总封装了</p><blockquote><p>注意点</p><ol><li>cin不能读入空格</li><li>感觉c++字符和字符的ASCII码的转换很灵活</li><li>判断某个元素是否在某个集合中出现过,可以<mark class="hl-label red">hash表,可以桶排序</mark> </li><li>hash表的各种操作时间复杂度是O(1)</li><li>#include<unodered_set></li></ol></blockquote><h2 id="1557-说话方式"><a href="#1557-说话方式" class="headerlink" title="1557. 说话方式"></a>1557. 说话方式</h2><p>这题自己确实不会</p><p>题目:</p><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-pat/2022-03-26_17-58-33.png" alt="2022-03-26_17-58-33"></p><p>这题y总的代码出乎我想象,用到了双指针和unordermap(哈希map)</p><p>自己用y总思路写的第一个版本的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="comment">//提取每一个单词,双指针的写法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(str[i]))&#123; <span class="comment">//看看是不是字母或者数字,第一个字母</span></span><br><span class="line">            string word;</span><br><span class="line">            <span class="keyword">int</span> j =i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>()&amp;&amp; <span class="built_in">check</span>(str[j])) word+=<span class="built_in">tolower</span>(str[j ++]);</span><br><span class="line">            hash[word] ++;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item :hash)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item.second&gt;cnt || item.second == cnt&amp;&amp; item.first&lt;word)&#123;</span><br><span class="line">            word = item.first;</span><br><span class="line">            cnt = item.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; word&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个if判断,我刚开始不理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(item.second&gt;cnt || item.second == cnt&amp;&amp; item.first&lt;word)</span><br></pre></td></tr></table></figure><p><strong>两个条件:</strong></p><p>1.item.second&gt;cnt</p><p>常用词只有一个的情况</p><p>2.item.second == cnt&amp;&amp; item.first&lt;word</p><p>常用词或许有多个,找出字典序最小的那一个</p><p>c++中字符串常用的函数</p><table><thead><tr><th>函数名称</th><th>函数作用</th></tr></thead><tbody><tr><td>isalnum()</td><td>如果参数是字母数字，即字母或数字，该函数返回true</td></tr><tr><td>tolower() / toupper()</td><td>如果参数是(小)大写字符，则返回其(大)小写，否则返回该参数</td></tr><tr><td>isalpha() / isdigit()</td><td>如果参数是字母或数字（0～9），该函数返回真</td></tr><tr><td>islower() / isupper()</td><td>如果参数是，该函数返回true</td></tr></tbody></table><h2 id="1493-电话账单"><a href="#1493-电话账单" class="headerlink" title="1493. 电话账单"></a>1493. 电话账单</h2><p>这题对字符串的操作运用要做到淋漓尽致,自己确实技不如人,不会写,下面是y总的代码,建议全部背下来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1440</span>*<span class="number">31</span>+<span class="number">10</span>,N=<span class="number">24</span>;</span><br><span class="line"><span class="keyword">int</span> cost[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> sum[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> minutes; <span class="comment">//把整个时间化为分钟</span></span><br><span class="line">    string state; <span class="comment">//这个记录的状态,off或者on</span></span><br><span class="line">    string format_time;<span class="comment">//格式化的时间</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Record&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> minutes &lt; t.minutes;</span><br><span class="line">    &#125; <span class="comment">//为了sort函数铺垫,按照分钟排序</span></span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string,vector&lt;Record&gt;&gt; persons; <span class="comment">//把名字和记录关联起来,记录为Record类型的vector</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++) cin &gt;&gt; cost[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;M;i++) sum[i] = sum[i<span class="number">-1</span>] + cost[(i<span class="number">-1</span>)%<span class="number">1440</span>/<span class="number">60</span>] / <span class="number">100.0</span>; <span class="comment">// 这里%1440是为了让其在一天的时间范围内,这里的思想是求前缀和,又因为那个是美分所以,要/100.0</span></span><br><span class="line">    cin &gt;&gt; n; <span class="comment">//多少记录</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>],state[<span class="number">10</span>],format_time[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> month,day,hour,minute;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d:%d:%d:%d %s&quot;</span>,name,&amp;month,&amp;day,&amp;hour,&amp;minute,state);</span><br><span class="line">        <span class="built_in">sprintf</span>(format_time,<span class="string">&quot;%02d:%02d:%02d&quot;</span>,day,hour,minute); <span class="comment">//给记录序列化</span></span><br><span class="line">        <span class="keyword">int</span> minutes = (day<span class="number">-1</span>)*<span class="number">1440</span>+hour*<span class="number">60</span>+minute; <span class="comment">//整体的minutes</span></span><br><span class="line">        persons[name].<span class="built_in">push_back</span>(&#123;minutes,state,format_time&#125;); <span class="comment">//放入map</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;person : persons)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> name = person.first; <span class="comment">//name名字</span></span><br><span class="line">        <span class="keyword">auto</span> records = person.second; <span class="comment">//记录Record</span></span><br><span class="line">        <span class="built_in">sort</span>(records.<span class="built_in">begin</span>(),records.<span class="built_in">end</span>()); <span class="comment">//给记录怕排序</span></span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>; <span class="comment">//费用总和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;records.<span class="built_in">size</span>();i++) <span class="comment">//已经按照时间顺序排序好了</span></span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">auto</span> a = records[i], b = records[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(a.state == <span class="string">&quot;on-line&quot;</span> &amp;&amp; b.state == <span class="string">&quot;off-line&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!total) <span class="built_in">printf</span>(<span class="string">&quot;%s %02d\n&quot;</span>,name.<span class="built_in">c_str</span>(),month);</span><br><span class="line">                cout &lt;&lt; a.format_time &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b.format_time&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                <span class="keyword">double</span> c = sum[b.minutes] - sum[a.minutes];<span class="comment">//费用总和</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d $%.2lf\n&quot;</span>,b.minutes - a.minutes,c);</span><br><span class="line">                total += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(total) <span class="built_in">printf</span>(<span class="string">&quot;Total amount: $%.2lf\n&quot;</span>,total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>y总的代码里面的精华:</p><ol><li>自己昨天晚上写这题,然后把同一个人的记录归类自己都不会,y总这里用的是map的思路,map里面的key是name,value是这个人的记录的vector(一个人下面可以挂扣很多记录),记录自己单独定义一个类,类的成员是总分钟数(需把整个时间转换为分钟),在线的状态和dd:hh:mm的字符串记录,</li><li>关于vector里面的数据排序问题,<code>sort(records.begin(),records.end());</code>,但是vector里面的数据类型是结构体,这个结构体怎么排序,就需要在结构题里面重新定义比较函数,就像左神给的那个比较器一样</li><li>一天24个小时,怎么计算这个钱的总数,感觉蛮复杂的,确实可以用到求前缀和的方法,把一整个区间都求出来,然后终点的值减去起点的值,怎么把这个区间画出来就需要技巧了,定义一个数组,数组的大小为31*1440+10(加上这个10是为了防止数组越界),cost[24]数组里面存的是价格区间,cost[(i-1)%1440/60]</li><li>sum[i] = sum[i-1] + cost[(i-1)%1440/60] / 100.0 这样就可以把这个区间给定义出来</li><li>printf(“%s %02d\n”,name.c_str(),month); 这里这个%02d,不够两位数,用0补齐(当时那个福尔摩斯的密码那道题,如果这样写的话应该会简单好多,还是y总的课好用),需要背代码了</li></ol></blockquote><h2 id="1494-银行排队"><a href="#1494-银行排队" class="headerlink" title="1494. 银行排队"></a>1494. 银行排队</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h3><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-pat/2022-03-27_22-57-10.png" alt="2022-03-27_22-57-10"></p><p>这题我竭尽全力了,太难了,这题和上一题思路略微类似,比以前进步一点的是会把类放vector里面运用了</p><p>自己代码只能写到这里了,太难了,看y总思路</p><pre><code>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"><span class="keyword">int</span> begin1 = <span class="number">3600</span> * <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> end1 = <span class="number">3600</span> * <span class="number">17</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> allsec; <span class="comment">//把到达时间转换为总秒数,和y总思路一样</span></span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Record&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> allsec &lt; t.allsec;</span><br><span class="line">    &#125; <span class="comment">//为了sort函数铺垫,按照分钟排序</span></span><br><span class="line">&#125;;<span class="comment">//一直到这里我和y总思路一样</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">timeout</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;a.size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=end1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Record&gt; a;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">int</span> b[K+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> hour,minute,second,time;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d %d&quot;</span>,&amp;hour,&amp;minute,&amp;second,&amp;time); <span class="comment">//和y总一样</span></span><br><span class="line">        <span class="keyword">int</span> allsec = <span class="number">3600</span>*hour + <span class="number">60</span> *minute + second;</span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;allsec,time&#125;);</span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    &#125; <span class="comment">//这一步已经解决</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i].allsec &gt; end1 + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i].allsec &lt;= begin1 &amp;&amp; <span class="built_in">istimeout</span>(b))&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// if(a[i].allsec &lt;= begin1 &amp;&amp; b[i/K]&lt;=end1)&#123;</span></span><br><span class="line">            <span class="comment">//     sum += (begin1 - a[i].allsec);</span></span><br><span class="line">            <span class="comment">//     b[i/K] += a[i].time;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// else if(a[i].allsec &gt; begin1 &amp;&amp; a[i].allsec &lt;= end1 &amp;&amp; b[i/K]&lt;=end1)&#123;</span></span><br><span class="line">            <span class="comment">//     sum += (b[i/K] - a[i].allsec);</span></span><br><span class="line">            <span class="comment">//     b[i/K] += a[i].time;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>y总思路,用小根堆来表示所有窗口,优先队列priority_queue&lt;int,vector<int>,greater<int>&gt; a;</p><p>time = min(3600,time);</p><p>将人安排到该窗口,怎么安排呢,累加等待时间,开始服务时间减去到达时间,end_time + 服务时间(新的结束时间) -&gt; 更新该窗口,优先队列不支持修改操作的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Record</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> allsec;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Record&amp; t) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> allsec &lt; t.allsec;</span><br><span class="line">    &#125; <span class="comment">//为了sort函数铺垫,按照分钟排序</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Record&gt; a;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> hour,minute,second,time;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d:%d:%d %d&quot;</span>,&amp;hour,&amp;minute,&amp;second,&amp;time);</span><br><span class="line">        time = <span class="built_in">min</span>(<span class="number">3600</span>,time*<span class="number">60</span>);</span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;<span class="number">3600</span>*hour + <span class="number">60</span> *minute + second,time&#125;);</span><br><span class="line">        <span class="comment">// a[i] = &#123;3600*hour + 60 *minute + second,60*time&#125;</span></span><br><span class="line">    &#125; <span class="comment">//这一步已经解决</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; windows;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;K;i++) windows.<span class="built_in">push</span>(<span class="number">8</span>*<span class="number">3600</span>);<span class="comment">//初始化窗口</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> person = a[i];</span><br><span class="line">        <span class="keyword">int</span> w = windows.<span class="built_in">top</span>();<span class="comment">//弹出最小值</span></span><br><span class="line">        windows.<span class="built_in">pop</span>(); <span class="comment">// 删除这个元素</span></span><br><span class="line">        <span class="keyword">if</span>(a[i].allsec &gt;  <span class="number">17</span>*<span class="number">3600</span>) <span class="keyword">break</span>; <span class="comment">//因为这是拍好序的</span></span><br><span class="line">        <span class="keyword">int</span> start_time = <span class="built_in">max</span>(person.allsec,w);</span><br><span class="line">        sum += start_time - person.allsec;</span><br><span class="line">        cnt ++;</span><br><span class="line">        windows.<span class="built_in">push</span>(start_time+person.time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>,(<span class="keyword">double</span>)sum/cnt/<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熬不动了,准备睡觉了</p><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="1474-多项式-A-B"><a href="#1474-多项式-A-B" class="headerlink" title="1474. 多项式 A + B"></a>1474. 多项式 A + B</h2><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-pat/2022-04-01_10-13-51.png" alt="2022-04-01_10-13-51"></p><p>这题自己一开始没有思路,忏愧呀,只需要两个浮点数组,下标当指数,值为系数</p><p>自己的代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>; <span class="comment">//多开10个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> a[N],b[N] = &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; k &gt;&gt;a[k];</span><br><span class="line">    cin &gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;m;i++) cin &gt;&gt; k &gt;&gt; b[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        a[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">            sum ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =N<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %.1lf &quot;</span>,i,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以精简一下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>; <span class="comment">//多开10个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> a[N],b[N] = &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; k &gt;&gt;a[k];</span><br><span class="line">    cin &gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;m;i++) cin &gt;&gt; k &gt;&gt; b[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        a[i] = a[i] + b[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]) sum ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =N<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %.1lf &quot;</span>,i,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1481-多项式乘积"><a href="#1481-多项式乘积" class="headerlink" title="1481. 多项式乘积"></a>1481. 多项式乘积</h2><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-pat/2022-04-01_10-47-01.png" alt="2022-04-01_10-47-01"></p><p>和上一题类似,代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>; <span class="comment">//多开10个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> a[N],b[N],c[<span class="number">2</span>*N] = &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) cin &gt;&gt; k &gt;&gt;a[k];</span><br><span class="line">    cin &gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;m;i++) cin &gt;&gt; k &gt;&gt; b[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">            c[i+j] += a[i]*b[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>*N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]) sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>*N<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d %.1lf &quot;</span>,i,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1500-趣味数字"><a href="#1500-趣味数字" class="headerlink" title="1500. 趣味数字"></a>1500. 趣味数字</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目:"></a>题目:</h3><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-pat/2022-04-01_11-05-28.png" alt="2022-04-01_11-05-28"></p><p>注意这里的输入的数字不超过20位</p><p>自己尝试使用long long int来输入,这个的最大长度是18位,所以必须用string</p><blockquote><p>自己的第一代代码</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> flag1[<span class="number">11</span>],flag2[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n,m,k;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n;</span><br><span class="line">    k = <span class="number">2</span>*m;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        flag1[n%<span class="number">10</span>]++;</span><br><span class="line">        n = n/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        flag2[k%<span class="number">10</span>]++;</span><br><span class="line">        k = k/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag1[i]!=flag2[i])&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt;endl;</span><br><span class="line">            cout &lt;&lt; <span class="number">2</span>*m &lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="number">2</span>*m &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自己的第二代代码</p></blockquote><p>仿照列竖式来做,也可以都放入一个vector数组,唯一的难点是进位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> flag1[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string n;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) a.<span class="built_in">push_back</span>(n[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//放入vector数组</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = a[i] + a[i] + t;</span><br><span class="line">        b.<span class="built_in">push_back</span>(s%<span class="number">10</span>);</span><br><span class="line">        t = s/<span class="number">10</span>;</span><br><span class="line">    &#125; <span class="comment">//上面的读入书顺序是为了这个铺叙</span></span><br><span class="line">    <span class="keyword">if</span>(t) b.<span class="built_in">push_back</span>(t);     <span class="comment">//注意这里的进位,自己当时忽略过这里所以耽误了好长时间</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c = b;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(a == c) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; <span class="comment">//昨天y总讲的vector数组可以数值比较</span></span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        cout &lt;&lt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PAT甲级的第一题需要熟练的运用c++的STL库,要是不能熟练运用,直接gg</p><h2 id="AcWing-1544-霍格沃茨的-A-B-简单题"><a href="#AcWing-1544-霍格沃茨的-A-B-简单题" class="headerlink" title="AcWing 1544. 霍格沃茨的 A + B(简单题)"></a>AcWing 1544. 霍格沃茨的 A + B(简单题)</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://secqin.oss-cn-beijing.aliyuncs.com/acwing-suanfa/2022-04-10_11-26-07.png" alt="2022-04-10_11-26-07"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Res</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> Galleon;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> Sickle;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> Knut;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Res&gt; a;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(c--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> Galleon,Sickle,Knut;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> Sum;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld.%lld.%lld&quot;</span>,&amp;Galleon,&amp;Sickle,&amp;Knut);</span><br><span class="line">        Sum = Knut + <span class="number">29</span>*Sickle + <span class="number">17</span>*<span class="number">29</span>*Galleon;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; Sum &lt;&lt;endl;</span></span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;Galleon,Sickle,Knut,Sum&#125;); <span class="comment">//放入进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    flag = a[<span class="number">0</span>].Sum+a[<span class="number">1</span>].Sum;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld.%lld.%lld\n&quot;</span>,flag/<span class="number">29</span>/<span class="number">17</span>,flag/<span class="number">29</span>%<span class="number">17</span>,flag%<span class="number">29</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我这是小题大作了</p></blockquote><p>第一次写一直在报错,一直是报溢出错误,我感觉Galleon,Sickle,Knut前面没有必要加long long,不加就会报错,这里感觉是被强制转换了,long long int直接被转换成了int</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="1476-数叶子结点"><a href="#1476-数叶子结点" class="headerlink" title="1476. 数叶子结点"></a>1476. 数叶子结点</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>家庭关系可以用家谱树来表示，给定一个家谱树，你的任务是找出其中没有孩子的成员。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含一个整数 $N$ 表示树中结点总数以及一个整数 $M$ 表示非叶子结点数。</p><p>接下来 $M$ 行，每行的格式为：</p><pre><code>ID K ID[1] ID[2] ... ID[K]</code></pre><p>$ID$ 是一个两位数字，表示一个非叶子结点编号，$K$ 是一个整数，表示它的子结点数，接下来的 $K$ 个 $ID[i]$ 也是两位数字，表示一个子结点的编号。</p><p>为了简单起见，我们将根结点固定设为 $01$。</p><p>所有结点的编号即为 $01,02,03,…,31,32,33,…,N$。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出从根结点开始，自上到下，树的<strong>每一层级</strong>分别包含多少个叶子节点。</p><p>输出占一行，整数之间用空格隔开。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$0 &lt; N &lt; 100$</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><pre><code>2 101 1 02</code></pre><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><pre><code>0 1</code></pre><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>该样例表示一棵只有 $2$ 个结点的树，其中 $01$ 结点是根，而 $02$ 结点是其唯一的子节点。</p><p>因此，在根这一层级上，存在 $0$ 个叶结点；在下一个级别上，有 $1$ 个叶结点。</p><p>所以，我们应该在一行中输出0 1。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> acwing </category>
          
          <category> pat </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> acwing </tag>
            
            <tag> pat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-左神的算法课</title>
      <link href="/2022/03/08/07-%E5%B7%A6%E7%A5%9E%E7%9A%84%E7%AE%97%E6%B3%95%E8%AF%BE/"/>
      <url>/2022/03/08/07-%E5%B7%A6%E7%A5%9E%E7%9A%84%E7%AE%97%E6%B3%95%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>c++选择排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">    arr[j]=arr[i]^arr[j];</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">123</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">456</span>,<span class="number">767</span>,<span class="number">43</span>,<span class="number">34</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;min)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c:a)&#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>c++冒泡排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">    arr[j]=arr[i]^arr[j];</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">123</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">123</span>,<span class="number">123</span>,<span class="number">456</span>,<span class="number">767</span>,<span class="number">43</span>,<span class="number">34</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">9</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(a,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c:a)&#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"># 归并排序</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,l,mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">merge</span>(arr,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> help[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// 辅助函数的指针</span></span><br><span class="line">    <span class="keyword">int</span> p1 = l; <span class="comment">//左指针</span></span><br><span class="line">    <span class="keyword">int</span> p2 = m+<span class="number">1</span>; <span class="comment">//右指针</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m&amp;&amp; p2 &lt;=r)&#123;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr [p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;=m)&#123;   <span class="comment">//当左边指针没有越界,就把左边全部考入进</span></span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2&lt;=r)&#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(help)/<span class="built_in"><span class="keyword">sizeof</span></span>(help[<span class="number">0</span>]);i++)&#123;</span><br><span class="line">        arr[l+i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">123</span>,<span class="number">125</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">32</span>,<span class="number">56</span>,<span class="number">789</span>,<span class="number">123</span>,<span class="number">456</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">mergeSort</span>(a,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树-2022-03-20"><a href="#树-2022-03-20" class="headerlink" title="树(2022.03.20)"></a>树(2022.03.20)</h1><blockquote><p>前段时间自己整了一个打印机,所以很长时间没有更新博客,感觉有些内容还是要写在博客上面,写博客一个关键的问题是无法方便的画图,后来发现markdown也有画流程图的语法,左神的算法课真是博大精深</p></blockquote><h2 id="数的前中后序遍历的两种实现方式-递归加非递归"><a href="#数的前中后序遍历的两种实现方式-递归加非递归" class="headerlink" title="数的前中后序遍历的两种实现方式(递归加非递归)"></a>数的前中后序遍历的两种实现方式(递归加非递归)</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><blockquote><p>递归方法其实蛮好理解的,递归就相当于系统帮我们压栈</p></blockquote><blockquote><p>树的节点</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">right</span>;</span></span><br><span class="line">    <span class="built_in">Node</span> (<span class="keyword">int</span> v,struct Node* l,struct Node* r)    <span class="comment">// 构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        left = l;</span><br><span class="line">        right = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>整棵树</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">5</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">8</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;left-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">4</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;left-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;right-&gt;left=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">7</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;right-&gt;left-&gt;left=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">6</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;right-&gt;right=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">10</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;right-&gt;right-&gt;left=<span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">9</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">head-&gt;right-&gt;right-&gt;right = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">11</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><blockquote><p>整棵树的图示</p></blockquote><pre class="mermaid">flowchart TB;  A((5))-->B((3))  A((5))-->C((8))  B((3))-->D((2))  B((3))-->E((4))  D((2))-->F((1))  C((8))-->G((7))  G((7))-->H((左6))  C((8))-->I((10))  I((10))-->J((9))  I((10))-->K((11))</pre><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout &lt;&lt; head-&gt;value &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preOrder</span>(head-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(head-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前序遍历的压栈示意图</p></blockquote><pre class="mermaid">flowchart TB;  A((5))-->|打印5,进入3|B((3))  A((5))-->C((8))  B((3))-->|打印3,进入2|D((2))  D((2))-->|返回3,找3的右\n子,发现4|B((3))  B((3))-->E((4))  E((4))-->|打印4,没有发现4的\n左右子,返回3|B((3))  D((2))-->|打印2,进入1|F((1))  F((1))-->|打印1,发现1的左右\n子为空,返回2,\n并找2的右子,发现没有|D((2))  C((8))-->G((7))  G((7))-->H((左6))  C((8))-->I((10))  I((10))-->J((9))  I((10))-->K((11))</pre><blockquote><p>markdown画图太复杂了,后面的过程依次类推,如果用Visio画图的画,需要截图上传,图床的空间不足了</p></blockquote><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(head-&gt;left);</span><br><span class="line">    cout &lt;&lt; head-&gt;value &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(head-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">posOrder</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">posOrder</span>(head-&gt;left);</span><br><span class="line">    <span class="built_in">posOrder</span>(head-&gt;right);</span><br><span class="line">    cout &lt;&lt; head-&gt;value &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><blockquote><p>非递归的方法可以通过栈来实现</p></blockquote><h4 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h4><h5 id="过程"><a href="#过程" class="headerlink" title="过程:"></a>过程:</h5><ol><li>把头节点压入栈中</li><li>从栈中弹出一个节点</li><li>打印这个节点的值;</li><li>然后先把右节点压入栈中,再压入左节点</li><li>周而复始</li></ol><h5 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h5><pre class="mermaid">flowchart LR    id1[(5)]    id2[(3\n8)]    id3[(2\n4)]    id1 -->|打印5,弹出5,\n放入8,再放入3| id2 --> |打印3,弹出3,\n放入4,再放入2|id3</pre><p>后面的依此类推</p><mark class="hl-label red">代码</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        stack&lt;Node*&gt;stack1;</span><br><span class="line">        stack1.<span class="built_in">push</span>(head);</span><br><span class="line">        <span class="keyword">while</span>(!stack1.<span class="built_in">empty</span>())&#123; <span class="comment">//栈为空就退出循环,同时栈为空整个代码结束</span></span><br><span class="line">            head = stack1.<span class="built_in">top</span>();</span><br><span class="line">            stack1.<span class="built_in">pop</span>(); <span class="comment">// 这一步蛮关键的,因为top(),返回栈顶元素,但是不弹出栈顶元素,需要手动删除,用pop手动弹出,pop弹出,不返回值</span></span><br><span class="line">            cout &lt;&lt; head-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stack1.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">            &#125; <span class="comment">//先压右</span></span><br><span class="line">            <span class="keyword">if</span>(head-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                stack1.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">            &#125; <span class="comment">//再压左</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;树没有节点&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><blockquote><p>关于中序遍历,这里稍微难理解一点</p></blockquote><h5 id="过程-1"><a href="#过程-1" class="headerlink" title="过程:"></a>过程:</h5><ol><li>先不断的左节点进栈</li><li>当最左边的节点没有了东西可以进栈了,就开始往外弹出节点,,并打印这个节点的值这个节点是全局最左的节点</li><li>然后让节点等于当前弹出节点的右节点,刚开始右节点是没有的,head就为空,但是栈不为空</li><li>继续弹出栈顶元素,这个栈顶元素是上一个弹出来节点的父节点,然后再找这个父节点的右节点,发现存在,不为空</li><li>然后压入这个右节点然后疯狂的找右节点的左节点</li><li>周而复始</li></ol><blockquote><p>我总结就是左节点最优先,先疯狂的找左节点,没有的话,再回溯,找右节点,一但找到一个右节点,就疯狂的顺着右节点找其左儿子,左孙子….</p></blockquote><mark class="hl-label pink">每颗子树,整棵树左边界进栈,依次弹出节点的过程中,对弹出节点的右树重复</mark> <p><strong>为什么这样就是中序呢?</strong></p><blockquote><p>因为所有树都可以被其左边界分解掉,左边界放到了栈里去<mark class="hl-label greed">头-->左</mark> 打印的顺序就是<mark class="hl-label orange">左头</mark> </p><p>我们 是让右树后去先左再头的</p></blockquote><p>如果看树那个图,关键是两个顺序:<mark class="hl-label red">右上和右下</mark> </p><p>感觉coding难度蛮大的</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    </pre></div><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><strong>左右头</strong></p><p>有两种写法</p><mark class="hl-label orange">带辅助栈的写法</mark> <p><strong>步骤</strong></p><ol><li>压入头节点</li><li>弹出头节点,将头节点放入辅助栈</li><li>先压入左,再压入右</li><li>周而复始</li></ol><p>栈弹出的时候就可以的把顺序逆过来,就是左右头</p><p><strong>代码:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">posOrderUnRecur</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        stack&lt;Node*&gt; s1;</span><br><span class="line">        stack&lt;Node*&gt; s2;</span><br><span class="line">        s1.<span class="built_in">push</span>(head);</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            head = s1.<span class="built_in">top</span>();</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">            s2.<span class="built_in">push</span>(head);</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s1.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;right!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s1.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cout &lt;&lt; s2.<span class="built_in">top</span>()-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熬不动了,我要睡了,明天写另一种实现方法</p><p><strong>代码:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">posOrderUnRecur2</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        stack&lt;Node*&gt; mystack;</span><br><span class="line">        mystack.<span class="built_in">push</span>(head); </span><br><span class="line">        Node *c = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(!mystack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            c = mystack.<span class="built_in">top</span>();</span><br><span class="line">            mystack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(c-&gt;left!= <span class="literal">nullptr</span>&amp;&amp;head!=c-&gt;left&amp;&amp;head!=c-&gt;right)&#123;</span><br><span class="line">                mystack.<span class="built_in">push</span>(c-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c-&gt;right != <span class="literal">nullptr</span>&amp;&amp;head!=c-&gt;right)&#123;</span><br><span class="line">                mystack.<span class="built_in">push</span>(c-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout &lt;&lt; mystack.<span class="built_in">top</span>()-&gt; value &lt;&lt;endl;</span><br><span class="line">                head = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码关键是怎么让每个节点不重复打印,感觉背下来最快,这段代码不算好理解的,直接找规律背下来</p></blockquote><h2 id="树的宽度优先-层序-遍历和二叉树的最大宽度"><a href="#树的宽度优先-层序-遍历和二叉树的最大宽度" class="headerlink" title="树的宽度优先(层序)遍历和二叉树的最大宽度"></a>树的宽度优先(层序)遍历和二叉树的最大宽度</h2><blockquote><p>左神的代码都是Java实现的,Java的STL库里面有hashmap,但是c++里面没有hashmap(hashmap在求二叉树的最大宽度里面需要)</p></blockquote><h3 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h3><blockquote><p>宽度优先遍历需要<mark class="hl-label red">队列</mark> ,先进先出</p></blockquote><p>步骤:</p><ol><li>先把头节点压到队列里面去</li><li>然后弹出头节点,并打印头节点</li><li>然后压入头节点的左子和右子(先左再右)</li></ol><p>这个过程较为简单就不画图示了</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">widthOrder</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">    queue&lt;Node*&gt;myqueue;</span><br><span class="line">    myqueue.<span class="built_in">push</span>(head);</span><br><span class="line">    Node* node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!myqueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node = myqueue.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; node-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        myqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            myqueue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            myqueue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求二叉树的最大宽度"><a href="#求二叉树的最大宽度" class="headerlink" title="求二叉树的最大宽度"></a>求二叉树的最大宽度</h3><blockquote><p>需要标记每一层的节点,java里面可以用hashmap</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">widthOrder</span><span class="params">(Node *head)</span></span>&#123;</span><br><span class="line">    queue&lt;Node*&gt;myqueue; <span class="comment">//层序遍历的队列</span></span><br><span class="line">    myqueue.<span class="built_in">push</span>(head); <span class="comment">//先把头节点放进去</span></span><br><span class="line">    unordered_map&lt;Node*,<span class="keyword">int</span>&gt;levelmap; <span class="comment">//控制层数的方式</span></span><br><span class="line">    levelmap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(head,<span class="number">1</span>));</span><br><span class="line">    Node* node = <span class="literal">nullptr</span>; <span class="comment">//辅助节点</span></span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>; <span class="comment">//最大的宽度</span></span><br><span class="line">    <span class="keyword">int</span> curWidth = <span class="number">0</span>;<span class="comment">//当前层有多少个节点</span></span><br><span class="line">    <span class="keyword">int</span> curLevel = <span class="number">0</span>; <span class="comment">//当前处在哪一层</span></span><br><span class="line">    <span class="keyword">while</span> (!myqueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        node = myqueue.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//        cout &lt;&lt; node-&gt;value &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        myqueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            levelmap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(node-&gt;left,levelmap[node]+<span class="number">1</span>));</span><br><span class="line">            myqueue.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125; <span class="comment">//这段代码好理解</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right!= <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            levelmap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(node-&gt;right,levelmap[node]+<span class="number">1</span>));</span><br><span class="line">            myqueue.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125; <span class="comment">// 这段代码好理解</span></span><br><span class="line">        <span class="keyword">if</span>(levelmap[node] &gt; curLevel)&#123;</span><br><span class="line">            curWidth = <span class="number">0</span>; <span class="comment">//当前层的节点个数</span></span><br><span class="line">            curLevel = levelmap[node]; <span class="comment">//当前处在哪一层</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curWidth++; <span class="comment">// 当前层节点的个数加</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxWidth = <span class="built_in">max</span>(maxWidth,curWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索二叉树"><a href="#搜索二叉树" class="headerlink" title="搜索二叉树"></a>搜索二叉树</h2><blockquote><p>怎么判断一棵二叉树是否是搜索二叉树</p></blockquote><p>搜索二叉树:</p><p>所有树的左子树里面的最大值小于其头节点</p><p>所有树的右子树里面的最小值大于其头节点</p><h3 id="解法一-动态规划解决-树形DP问题"><a href="#解法一-动态规划解决-树形DP问题" class="headerlink" title="解法一:动态规划解决(树形DP问题)"></a>解法一:动态规划解决(树形DP问题)</h3><p>左神的代码思想是动态规划,动态规划需要左子树和右子树返回的信息是一样的,这个地方左子树和右子树需要返回的信息不一样,一个是最大值,一个是最小值,为了保证动态规划的思想,所以求并集,左右两边同时返回最大值和最小值,然后和头节点比较大小,不管哪棵树都返回3个信息,最大值和最小值,和是否是搜索二叉树(bool值)</p><mark class="hl-label green">昨天把左神的代码改为c++发现一个问题,就是自己自定义了一个类作为返回值,但是假设传入的节点为空,那个返回值不能置空,还在寻找解决办法</mark> <p>查了蛮多资料,java都是引用类型,c++的类不是引用类型,所以c++不能返回空对象</p><blockquote><p>递归函数的返回函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnData</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isBST;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ReturnData</span>(<span class="keyword">bool</span> i,<span class="keyword">int</span> mi,<span class="keyword">int</span> ma)&#123;</span><br><span class="line">        isBST = i;</span><br><span class="line">        min = mi;</span><br><span class="line">        max = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>递归函数</p></blockquote><mark class="hl-label pink">关于返回空值有两种解决方案</mark> ,一种是把process的返回值定义为指针类型,第二种是就定义为那个实体类类型,当节点为空的时候,就返回<mark class="hl-label red">ReturnData(false,-1,-1)</mark>  然后在下面判断的时候就不是判断其是否为空,而是判断其的最小值或者最大值是否为-1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnData* <span class="title">process</span><span class="params">(Node* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="comment">//        return ReturnData(false,-1,-1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData *leftData = <span class="built_in">process</span>(x-&gt;left); <span class="comment">//处理左子树</span></span><br><span class="line">    ReturnData *rightData = <span class="built_in">process</span>(x-&gt;right); <span class="comment">//处理右子树 ,这两段代码把左右子树全部搞定了</span></span><br><span class="line">    <span class="keyword">int</span> min1 = x-&gt;value; <span class="comment">//接下来就是处理头节点</span></span><br><span class="line">    <span class="keyword">int</span> max1 = x-&gt;value;</span><br><span class="line">    <span class="keyword">if</span>(leftData != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        min1 = <span class="built_in">min</span>(min1,leftData-&gt;min);</span><br><span class="line">        max1 = <span class="built_in">max</span>(max1,leftData-&gt;max);</span><br><span class="line">    &#125; <span class="comment">//左树的最大值和最小值分别和头节点比较</span></span><br><span class="line">    <span class="keyword">if</span>(rightData != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        min1 = <span class="built_in">min</span>(min1,rightData-&gt;min);</span><br><span class="line">        max1 = <span class="built_in">max</span>(max1,rightData-&gt;max);</span><br><span class="line">    &#125;<span class="comment">//右树的最大值和最小值分别和头节点比较</span></span><br><span class="line">    <span class="keyword">bool</span> isBST = <span class="literal">true</span>; <span class="comment">//假设此时为搜索二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (leftData!= <span class="literal">nullptr</span> &amp;&amp; (!leftData-&gt;isBST || leftData-&gt;max &gt;= x-&gt;value))&#123;</span><br><span class="line">        isBST = <span class="literal">false</span>; <span class="comment">//进入if的条件:左边不为空,同时(左数为搜索二叉树或者左数的最大值大于头节点的值)(左数不是搜索二叉树,但是左数的最大值大于头节点的值)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightData!= <span class="literal">nullptr</span> &amp;&amp; (!rightData-&gt;isBST||x-&gt;value &gt;= rightData-&gt;min))&#123;</span><br><span class="line">        isBST = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ReturnData</span>(isBST,min1,max1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以把代码拆散来看</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnData* <span class="title">process</span><span class="params">(Node* x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="comment">//base case</span></span><br><span class="line">    ReturnData *leftData = <span class="built_in">process</span>(x-&gt;left);  <span class="comment">//返回左数信息</span></span><br><span class="line">    ReturnData *rightData = <span class="built_in">process</span>(x-&gt;right);  <span class="comment">//返回右树信息</span></span><br><span class="line">    <span class="keyword">int</span> min1 = x-&gt;value; <span class="comment">//自己的value</span></span><br><span class="line">    <span class="keyword">int</span> max1 = x-&gt;value;<span class="comment">//自己的value</span></span><br><span class="line">    <span class="keyword">bool</span> isBST = <span class="literal">true</span>; <span class="comment">//假设此时树为搜索二叉树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ReturnData</span>(isBST,min1,max1); <span class="comment">//返回自己的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>处理min1,max1和isBST(自己和左子树右子树比较)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(leftData != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    min1 = <span class="built_in">min</span>(min1,leftData-&gt;min);</span><br><span class="line">    max1 = <span class="built_in">max</span>(max1,leftData-&gt;max);</span><br><span class="line">&#125; <span class="comment">//左树的最大值和最小值分别和头节点比较</span></span><br><span class="line"><span class="keyword">if</span>(rightData != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    min1 = <span class="built_in">min</span>(min1,rightData-&gt;min);</span><br><span class="line">    max1 = <span class="built_in">max</span>(max1,rightData-&gt;max);</span><br><span class="line">&#125;<span class="comment">//右树的最大值和最小值分别和头节点比较</span></span><br><span class="line"><span class="keyword">bool</span> isBST = <span class="literal">true</span>; <span class="comment">//假设此时为搜索二叉树</span></span><br><span class="line"><span class="keyword">if</span> (leftData!= <span class="literal">nullptr</span> &amp;&amp; (!leftData-&gt;isBST || leftData-&gt;max &gt;= x-&gt;value))&#123;</span><br><span class="line">    isBST = <span class="literal">false</span>; <span class="comment">//进入if的条件:左边不为空,同时(左数为搜索二叉树或者左数的最大值大于头节点的值)(左数不是搜索二叉树,但是左数的最大值大于头节点的值)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rightData!= <span class="literal">nullptr</span> &amp;&amp; (!rightData-&gt;isBST||x-&gt;value &gt;= rightData-&gt;min))&#123;</span><br><span class="line">    isBST = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二-利用中序遍历解决"><a href="#解法二-利用中序遍历解决" class="headerlink" title="解法二:利用中序遍历解决"></a>解法二:利用中序遍历解决</h3><p>多加一个list或者数组,把中序遍历的结果放入里面,然后遍历如果是按照从大到小排序就是搜索二叉树</p><p>代码比较简单,就不敲了</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><pre class="mermaid">flowchart TB;  A((5))-->B((3))  A((5))-->C((8))  B((3))-->D((2))  B((3))-->E((4))  D((2))-->F((1))  C((8))-->G((7))  C((8))-->I((10))</pre><p>这是完全二叉树(只有一个节点没有标注右,那么默认是左子树)</p><p>不违规的条件:</p><ol><li>有右孩子,但是没有左孩子,返回false</li><li>在(1)不违规时,如果遇到了第一个左右孩子不双全的情况,那么接下来遇到的都必须是叶节点</li></ol><p>是不是叶节点用一个bool变量来表示</p><p>也就是说两个条件无论违背哪一个都不算完全二叉树</p><p>也就是说中一个条件直接就判断false</p><p><strong>代码:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCBT</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;Node *&gt; queue1;</span><br><span class="line">    <span class="keyword">bool</span> leaf = <span class="literal">false</span>;</span><br><span class="line">    Node *l = <span class="literal">nullptr</span>;</span><br><span class="line">    Node *r = <span class="literal">nullptr</span>;</span><br><span class="line">    queue1.<span class="built_in">push</span>(head);</span><br><span class="line">    <span class="keyword">while</span> (!queue1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        head = queue1.<span class="built_in">front</span>();</span><br><span class="line">        queue1.<span class="built_in">pop</span>();</span><br><span class="line">        l = head-&gt;left;</span><br><span class="line">        r = head-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> ((leaf &amp;&amp; (l != <span class="literal">nullptr</span> || r != <span class="literal">nullptr</span>)) || (l == <span class="literal">nullptr</span> &amp;&amp; r != <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue1.<span class="built_in">push</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            queue1.<span class="built_in">push</span>(r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leaf = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><blockquote><p>什么叫平衡二叉树呢</p></blockquote><p>二叉树的高度差不能超过1</p><p>这题依然采用树形DP解法来解,动态规划,</p><mark class="hl-label red">第一步:</mark> <p>找清楚需要左子树和右子树返回什么信息:</p><ol><li>左树得是平衡二叉树</li><li>右树得是平衡二叉树</li><li>|左高-右高| &lt;=1</li></ol><p>那么需要2个变量,bool,和这棵树的高度int</p><blockquote><p>返回值结构</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnData1</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isBT;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="built_in">ReturnData1</span>(<span class="keyword">bool</span> i,<span class="keyword">int</span> h)&#123;</span><br><span class="line">        isBT = i;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自己根据树形DP思想写的代码:报错了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnData1 *<span class="title">process1</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData1 *leftTree = <span class="built_in">process1</span>(head-&gt;left);</span><br><span class="line">    ReturnData1 *rightTree = <span class="built_in">process1</span>(head -&gt; right);</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> isBT = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!leftTree&amp;&amp;!rightTree&amp;&amp;(<span class="built_in">abs</span>(leftTree-&gt;height - rightTree-&gt;height) &gt; <span class="number">1</span> || leftTree-&gt;isBT != <span class="literal">true</span> || rightTree-&gt;isBT != <span class="literal">true</span>))&#123;</span><br><span class="line">        isBT = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ReturnData1</span>(isBT,height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左神的代码改为c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ReturnData1 *<span class="title">process1</span><span class="params">(Node* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ReturnData1</span>(<span class="literal">true</span>,<span class="number">0</span>); <span class="comment">//base case,默认空树是平衡二叉树,并且高度为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    ReturnData1 *leftTree = <span class="built_in">process1</span>(head-&gt;left);</span><br><span class="line">    ReturnData1 *rightTree = <span class="built_in">process1</span>(head -&gt; right);</span><br><span class="line">    <span class="keyword">int</span> height = <span class="built_in">max</span>(leftTree-&gt;height ,rightTree-&gt;height)+<span class="number">1</span>; <span class="comment">//左神的代码给出的课后是错的,这里需要加1,这里的1是我的高度,我的高度等于左右树高度最大值加上本身的高度,本身的高度为1</span></span><br><span class="line">    <span class="keyword">bool</span> isBT = leftTree-&gt;isBT&amp;&amp;rightTree-&gt;isBT&amp;&amp; <span class="built_in">abs</span>(leftTree-&gt;height-rightTree-&gt;height)&lt;<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ReturnData1</span>(isBT,height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一:"></a>解法一:</h3><p>用hashmap记录下每一条链,就不改c++了直接用狂神的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Record1</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Node, Node&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Record1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line"><span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">map.put(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">setMap(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMap</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">map.put(head.left, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">map.put(head.right, head);</span><br><span class="line">&#125;</span><br><span class="line">setMap(head.left);</span><br><span class="line">setMap(head.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">query</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">HashSet&lt;Node&gt; path = <span class="keyword">new</span> HashSet&lt;Node&gt;();</span><br><span class="line"><span class="keyword">while</span> (map.containsKey(o1)) &#123;</span><br><span class="line">path.add(o1);</span><br><span class="line">o1 = map.get(o1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!path.contains(o2)) &#123;</span><br><span class="line">o2 = map.get(o2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> o2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小tips</p></blockquote><p>这题左神想复杂了</p><p>其实可以用快慢指针来求,在leetcode里面刷到过两题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">lca</span><span class="params">(Node *head,Node *o1,Node *o2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head == o1 || head == o2)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125; <span class="comment">//遇到o1遇到o2,或者遇到null直接返回本身,没有遇到o1或者o2都是返回null(这里看最后一行代码)</span></span><br><span class="line">    Node *left = <span class="built_in">lca</span>(head-&gt;left,o1,o2); <span class="comment">//这里的做法相当于把left一下拉到最下面和最左树了</span></span><br><span class="line">    Node *right = <span class="built_in">lca</span>(head-&gt;right,o1,o2); <span class="comment">//这里的做法相当于把最左树的right拉到最下面和最右面了</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right!= <span class="literal">nullptr</span>)&#123;  <span class="comment">//两个同时不为空就成立,就返回本身,case1不可能在这个if这里成立</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">nullptr</span>?left:right; <span class="comment">//返回不为NULL的那一个值,当两个孩子都为空,那么就返回null,既没有o1也没有o2就返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre class="mermaid">flowchart TB;  A((5))-->B((3))  A((5))-->C((8))  B((3))-->D((2))  B((3))-->E((4))  D((2))-->F((1))  C((8))-->G((7))  C((8))-->I((10))</pre><p>这个代码<mark class="hl-label red">大写的牛逼!!!</mark> </p><h2 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h2><p><strong>可以中序遍历,但是中序遍历是O(N)的复杂度,怎么把遍历的复杂度调到O(k),就要找后继节点的规律</strong></p><p>后继节点有三种情况</p><mark class="hl-label red">第一种:x有右子树</mark> <pre class="mermaid">flowchart TB;  A((x))-->C((8右))  I((10左))-->D((7左))  C((8右))-->I((10左))</pre><p>x的后继节点为右树的最左节点</p><mark class="hl-label red">第二种:x无右子树</mark> <pre class="mermaid">flowchart TB;  A((x))-->C((8左))  I((10右))-->D((7右))  C((8左))-->I((10右))</pre><p>x是(7右)的后继节点</p><mark class="hl-label red">第三种:x全部是右子树</mark> <pre class="mermaid">flowchart TB;  A((x))-->C((8右))  I((10右))-->D((7右))  C((8右))-->I((10右))</pre><p>7右没有后继节点</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getSuccessorNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == null) &#123;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (node.right != null) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getLeftMost</span>(node.right); <span class="comment">//假设有右子树,一直找右子树的最左节点</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//无右子树</span></span><br><span class="line">Node parent = node.parent;</span><br><span class="line"><span class="keyword">while</span> (parent != null &amp;&amp; parent.left != node) &#123; <span class="comment">//假设节点带父指针,父亲不为空,同时是父亲的右儿子,这一段代码可以囊括2,3两种情况</span></span><br><span class="line">node = parent;</span><br><span class="line">parent = node.parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLeftMost</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == null) &#123;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (node.left != null) &#123;</span><br><span class="line">node = node.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说心里话我感觉还是中序遍历更简单,自己不是优化狂魔</p></blockquote><mark class="hl-label yellow">听课两个半小时,整理代码两天,人搞疲了</mark> <h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图的算法都不难,但是繁琐,图的表达方式太多变了,所以要找一个自己喜欢的表达方式,然后把其他不同的表达方式转化为这个相同的表达方式,左神给出了一套较为完美的表达方式,自己就按照这个来写图了,图的话,我还是采用java来写了,c++里面的hashmap和set集合我不好实现,加油呀,冲冲冲!!!!</p><blockquote><p>点集:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; <span class="comment">//点集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value; <span class="comment">//这个点的权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> in; <span class="comment">//这个点的入度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> out; <span class="comment">//这个点的出度</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts; <span class="comment">//这个节点直接相邻的那些节点</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges; <span class="comment">//这个节点往外指出的边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>; <span class="comment">//这个地方this.out和out有那些区别呢?</span></span><br><span class="line">        nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>边集</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123; <span class="comment">//边集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value; <span class="comment">//这个边的权重</span></span><br><span class="line">    <span class="keyword">public</span> Node from; <span class="comment">//这个边的起点</span></span><br><span class="line">    <span class="keyword">public</span> Node to; <span class="comment">//这个边的终点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> value,Node from,Node to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>图集</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123; <span class="comment">//图集</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer,Node&gt; nodes;<span class="comment">//编了号的点集</span></span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;<span class="comment">//边集,这个地方的set不知道撒什么</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span></span>&#123; <span class="comment">//初始化</span></span><br><span class="line">        nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>转换器</p></blockquote><p>不管图给出的表达形式是哪种,自己想办法把那个图转换为左神给的这个表达方式</p><mark class="hl-label red">邻接矩阵转换为这个图的表达方式</mark> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphGenerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Graph <span class="title">createGraph</span><span class="params">(Integer[][] matrix)</span></span>&#123;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            Integer weight = matrix[i][<span class="number">0</span>]; <span class="comment">//这个临界矩阵的权重(这个权重指的是边的权重)排第几位,按位数来</span></span><br><span class="line">            Integer from = matrix[i][<span class="number">1</span>];</span><br><span class="line">            Integer to = matrix[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(!graph.nodes.containsKey(from))&#123; <span class="comment">//看看此时以我为表达方式的图里面是否有这个节点,要是没有进入if</span></span><br><span class="line">                graph.nodes.put(from,<span class="keyword">new</span> Node(from)); <span class="comment">// 放入from节点,这个节点的编号是其权重</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!graph.nodes.containsKey(to))&#123; <span class="comment">//看看此时以我为表达方式的图里面是否有这个节点,要是没有进入if</span></span><br><span class="line">                graph.nodes.put(to,<span class="keyword">new</span> Node(to)); <span class="comment">// 放入from节点,这个节点的编号是其权重</span></span><br><span class="line">            &#125; <span class="comment">//上面这两个if是把点放进去了,接下来该边放入了</span></span><br><span class="line">            Node fromNode = graph.nodes.get(from);<span class="comment">//拿出起始节点</span></span><br><span class="line">            Node toNode = graph.nodes.get(to); <span class="comment">//拿出要到的节点</span></span><br><span class="line">            Edge newEdge = <span class="keyword">new</span> Edge(weight,fromNode,toNode);</span><br><span class="line">            fromNode.nexts.add(toNode);<span class="comment">//起始节点的下一个节点是终点,这个地方其实还是在操作点,点的下一个节点</span></span><br><span class="line">            fromNode.out++;</span><br><span class="line">            toNode.in++;</span><br><span class="line">            fromNode.edges.add(newEdge); <span class="comment">//从这个点出去的边要加上,加在这个节点里面</span></span><br><span class="line">            graph.edges.add(newEdge); <span class="comment">//在图里面加上边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整体是在操作graph</strong></p><mark class="hl-label green">图的算法都不难,难就难在图的表达多种多样</mark> <h2 id="图的宽度优先遍历-BFS"><a href="#图的宽度优先遍历-BFS" class="headerlink" title="图的宽度优先遍历(BFS)"></a>图的宽度优先遍历(BFS)</h2><mark class="hl-label red">怎么保证图里面的节点不被重复遍历?这是问题的关键所在</mark> <p>就需要用到set集合,这个set集合就是保证点不被重复遍历</p><p>假设图的样子这样</p><pre class="mermaid">flowchart LR;  A((A))  B((B))  C((C))  D((D))  E((E))  A--- E--- D  A---C---D  A---B---D  C---B---E</pre><p>还是专业的画图工具强,markdown自带的画图工具功能不够完善,但是每次都要在precesson上面画图,然后截图上传到图床上面,图床早晚会空间不足</p><p>需要用到两个STL工具set和queue(树也是用这个宽度优先遍历必备)</p><p>先把头节点压入队列中,然后poll出头节点,然后操作头节点(可以是打印,也可以是其他操作),然后把poll出来的节点装入set集合中,每一次都检查poll出来的节点,是否在set集合里面,要是不在,就正常操作,要是在就节点.next</p><p>BFS遍历只用传入一个节点就行,后面的有点操作需要传入图graph</p><blockquote><p>ikbc的c200的红轴敲起来嘎嘎舒服</p></blockquote><p>我现在发现写题不能拘泥与某一种语言,写字符串相关的题可以用python,链表用c++,图就用java,pat甲级怎么可以得高分怎么来</p><p>代码里面的这句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>本想找队列Queue，发现那是一个接口，LinkedList实现了Queue接口，可以当作队列来用。</p></blockquote><p>一、概述</p><ol><li>Java的LinkedList是一种常用的数据容器，与ArrayList相比，LinkedList的增删操作效率更高，而查改操作效率较低。</li><li>LinkedList 实现了Queue接口，能当作队列使用。</li><li> LinkedList 实现了List 接口，能对它进行列表操作。</li><li> LinkedList 实现了Deque 接口，即能将LinkedList当作双端队列使用。</li><li> LinkedList 实现了Cloneable接口，能克隆。</li><li> LinkedList 实现了java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</li></ol><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">code1BFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//set集合,防止访问到重复元素</span></span><br><span class="line">        queue.add(node);</span><br><span class="line">        map.add(node);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node cur = queue.poll(); <span class="comment">//弹出这个节点</span></span><br><span class="line">            System.out.println(cur.value); <span class="comment">//操作这节点</span></span><br><span class="line">            <span class="keyword">for</span>(Node next:node.nexts)&#123; <span class="comment">//一直对着某一个节点疯狂的next,相当于把这个节点的全部的直接相邻节点都给拿出来了</span></span><br><span class="line">                <span class="keyword">if</span>(!map.contains(next))&#123; <span class="comment">//判断node的下一个是不是在这个map中,在的话就不操作</span></span><br><span class="line">                    map.add(next); <span class="comment">//要是这个set里面没有,就加上</span></span><br><span class="line">                    queue.add(next); <span class="comment">//然后加到这个队列中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的深度优先遍历-DFS"><a href="#图的深度优先遍历-DFS" class="headerlink" title="图的深度优先遍历(DFS)"></a>图的深度优先遍历(DFS)</h2><blockquote><p>和树的深度一样需要用到栈结构</p></blockquote><p>这个就和那个next一路走到底就不一样了,这个走一个next就需要弹出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">code2DFS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        stack.add(node);</span><br><span class="line">        set.add(node);</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            <span class="keyword">for</span>(Node next:node.nexts)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(next)) &#123;</span><br><span class="line">                    stack.push(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                    System.out.println(next.value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和宽度的区别的关键在于那个数据结构用的不一样一个是用队列,一个是用栈</p><p>还有一个不同是那个break;一个需要next到底,一个是找到一个next里面就顺着这个next找其他的next</p></blockquote><p>我有一点疑惑,<mark class="hl-label red">就是这里的栈感觉可以换成队列,上面的那个队列也可以换成栈,毕竟每次都是压入一个数据进栈</mark> ,后面再去尝试</p><h2 id="图的拓扑排序算法-TS"><a href="#图的拓扑排序算法-TS" class="headerlink" title="图的拓扑排序算法(TS)"></a>图的拓扑排序算法(TS)</h2><p>什么是图拓扑排序算法?</p><p>就像安装linux软件包,一个软件包不断的依赖其他的软件包,但是突然出现一种A软件包依赖B软件包.B软件包也依赖A软件包,那么两个软件包就互相依赖,就形成的环,就会出bug,就像你想去办理一个手续,去公安局办理,公安局说你先要去教育局办理一个手续,去了教育局,教育局里面的人说要是你想办理这个手续,你需要去公安局办理,互相踢皮球,就出现bug了</p><blockquote><p>DFS和BFS都是传入一个节点就够了</p></blockquote><p>TS算法需要传入图graph,因为需要操作边,每删除一个点都要消去这个点的直接相邻的边</p><ol><li>找到入度为0的点,然后删除这个点(找到入度为0的点一并删除掉很关键,入度为0的点全部放到一个队列里面)</li><li>然后删除这个点的直接相邻边,消除这个点对直接相邻节点的影响</li></ol><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">code03TS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">sortTopology</span><span class="params">(Graph graph)</span></span>&#123;</span><br><span class="line">        HashMap&lt;Node,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//存点和点的入度</span></span><br><span class="line">        Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//放0入度的队列</span></span><br><span class="line">        <span class="keyword">for</span>(Node node : graph.nodes.values())&#123; <span class="comment">//这个value是值hashmap的value,因为graph里面的点是以hashdmap形式存在,把图里面的点往外拿</span></span><br><span class="line">            map.put(node, node.in);<span class="comment">//放入点和点的入度</span></span><br><span class="line">            <span class="keyword">if</span>(node.in == <span class="number">0</span>)&#123;</span><br><span class="line">                zeroInQueue.add(node); <span class="comment">//先自己人为找一个入度为0的节点,加入这里面</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//将拓扑排序的结果存这里面</span></span><br><span class="line">        <span class="keyword">while</span>(!zeroInQueue.isEmpty())&#123; <span class="comment">//入度为0的队列慢慢弹空</span></span><br><span class="line">            Node cur = zeroInQueue.poll(); <span class="comment">//从队列中弹出一个</span></span><br><span class="line">            result.add(cur); <span class="comment">//加入到结果List中</span></span><br><span class="line">            <span class="keyword">for</span>(Node next:cur.nexts)&#123; <span class="comment">//将这个入度为0的节点的直接邻节点的入度全部减1</span></span><br><span class="line">                map.put(next, map.get(next)-<span class="number">1</span>); <span class="comment">//消除这个入度为0的节点的影响</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(next) == <span class="number">0</span>)&#123; <span class="comment">//找出剪完后入度为0的点,假设没有这个点了,那么不是拓扑排序了,就进入踢皮球状态了</span></span><br><span class="line">                    zeroInQueue.add(next); <span class="comment">//给加入到0节点的队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的Kruskal算法-无向图k算法"><a href="#图的Kruskal算法-无向图k算法" class="headerlink" title="图的Kruskal算法(无向图k算法)"></a>图的Kruskal算法(无向图k算法)</h2><blockquote><p>要找到一条权重最低的路径使得这条路的权重最低</p></blockquote><mark class="hl-label red">这题的关键是在添加的时候判断点与点之间是否会形成环,用集合来表达</mark> <p>步骤:<mark class="hl-label red">下面的步骤我写错了,当时写笔记写错了</mark> </p><ol><li><p>给出整个的图示</p><pre class="mermaid">   flowchart LR;  A((A))  B((B))  C((C))  D((D))  A ---|3| B ---|2| D  A ---|100| C---|10000| D  A ---|7| D  C ---|5| B</pre></li><li><p>从A点出发,找到权重最低的临边,发现是3,把边连上,然后检查有没有形成环,发现没有形成</p><pre class="mermaid">   flowchart LR;  A((A))  B((B))  C((C))  D((D))  A ---|3| B</pre></li><li><p>然后进入A的next,B点,然后找A和B的权重最小的临边,发现是2,把边连上,然后检查有没有形成环,发现没有形成</p><pre class="mermaid">   flowchart LR;  A((A))  B((B))  C((C))  D((D))  A ---|3| B ---|2| D</pre></li><li><p>然后找A,B,D的next节点权重最小的点B–&gt;C,把边连上,然后检查也没有形成环,发现没有形成</p><pre class="mermaid">   flowchart LR;  A((A))  B((B))  C((C))  D((D))  A ---|3| B ---|2| D  B ---|5 | C</pre><blockquote><p>结束,已经遍历了所有的节点</p></blockquote><p>这样做的难点是怎么检查没有形成环,左神说这里需要用到并查集,但是并查集是在后面提高班讲的,所以这里换一种思路,用集合来表示点之间是否连在一起了</p><ol><li>一开始的集合为{A},{B},{C},{D}</li><li>经过了第二部集合就变为{A,B},{C},{D}</li><li>{A,B,D},{C}</li><li>{A,B,C,D}</li></ol><p>每一次都检查这两个点是不是在集合中,要是在就会形成环,就会重复遍历节点,要是不在就合并集合</p><mark class="hl-label red">上面的步骤我写错了,应该是先把所有的边按从小到大排序,然后一条一条加最小的边,看看是否会形成环,如果可以形成环,那么就不加这条边</mark> </li><li><p>一开始的集合为{A},{B},{C},{D}(发现边BD最小,然后判断BD是不是在同一个集合呢,发现不是,那么就不会形成环)</p></li><li><p>经过了第二部集合就变为{A},{B,D},{C},{D}</p></li><li><p>{A,B,D},{C}</p></li><li><p>{A,B,C,D}</p></li></ol><p>并查集很快,但是现在这个基础班还讲不了,进阶班里面有</p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">K</span> </span>&#123; <span class="comment">//k算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mysets</span></span>&#123; <span class="comment">//我的集合们</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Node, List&lt;Node&gt;&gt; setMap; <span class="comment">//一个点对应的list是谁,一个节点对一个List内存地址</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Mysets</span><span class="params">(List&lt;Node&gt; nodes)</span></span>&#123;</span><br><span class="line">            <span class="comment">//初始化需要把所有的点都给我,一开始一个点所在的集合只有自己</span></span><br><span class="line">            <span class="keyword">for</span>(Node cur:nodes)&#123;</span><br><span class="line">                List&lt;Node&gt; set = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">                set.add(cur); <span class="comment">//list里面加上这个点</span></span><br><span class="line">                setMap.put(cur,set); <span class="comment">//注册在set里面</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node from,Node to)</span></span>&#123;</span><br><span class="line">            <span class="comment">//两个点在不在同一个集合里面</span></span><br><span class="line">            List&lt;Node&gt; fromSet = setMap.get(from);</span><br><span class="line">            List&lt;Node&gt; toSet = setMap.get(to);</span><br><span class="line">            <span class="keyword">return</span> fromSet == toSet; <span class="comment">//是不是同一个内存地址,假设是同一个内存地址就返回为true,说明会形成环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node from,Node to)</span></span>&#123;</span><br><span class="line">            List&lt;Node&gt; fromSet = setMap.get(from);</span><br><span class="line">            List&lt;Node&gt; toSet = setMap.get(to);</span><br><span class="line">            <span class="keyword">for</span>(Node toNode:toSet)&#123; <span class="comment">//把to的节点全部拿出来</span></span><br><span class="line">                fromSet.add(toNode);</span><br><span class="line">                setMap.put(toNode,fromSet); <span class="comment">//to的节点的list指向全部指向from</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//没有并查集快</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自己的问题还是在于对于java的集合类不熟悉</p><p>对于边的权值比大小,建议用比较器</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 左神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 左神 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16-AcWing算法基础课(c++基础)</title>
      <link href="/2022/02/22/05-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-c-%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/22/05-AcWing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-c-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-菱形"><a href="#1-菱形" class="headerlink" title="1.菱形"></a>1.菱形</h1><h2 id="1-1-题目"><a href="#1-1-题目" class="headerlink" title="1.1 题目"></a>1.1 题目</h2><p>输入一个奇数n，输出一个由‘*’构成的n阶实心菱形。</p><h2 id="1-2-实例输出"><a href="#1-2-实例输出" class="headerlink" title="1.2 实例输出"></a>1.2 实例输出</h2><p>若n=5;</p><blockquote><p>输出:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  *  </span><br><span class="line"> *** </span><br><span class="line">*****</span><br><span class="line"> *** </span><br><span class="line">  *  </span><br></pre></td></tr></table></figure><h2 id="1-3-算法思想"><a href="#1-3-算法思想" class="headerlink" title="1.3 算法思想"></a>1.3 算法思想</h2><p><strong>曼哈顿距离算法</strong></p><p>我们常见的距离是欧式距离,x轴和y轴的差的平方</p><p>曼哈顿距离中的距离计算：</p><p><img src="https://gitee.com/secqin/img/raw/master/aHR0cDovL3d3dy5nbzYwLnRvcC91cGxvYWRzL2FsbGltZy8xODA5MjQvMS0xUDkyNDEwNTkxNTVhLmpwZw.jpg" alt="aHR0cDovL3d3dy5nbzYwLnRvcC91cGxvYWRzL2FsbGltZy8xODA5MjQvMS0xUDkyNDEwNTkxNTVhLmpwZw"></p><p>我们这个题目需要的二维曼哈顿距离</p><table><thead><tr><th align="center">(0,0)</th><th align="center">(0,1)</th><th align="center">(0,2)</th><th align="center">(0,3)</th><th align="center">(0,4)</th></tr></thead><tbody><tr><td align="center">(1,0)</td><td align="center">(1,1)</td><td align="center">(1,2)</td><td align="center">(1,3)</td><td align="center">(1,4)</td></tr><tr><td align="center">(2,0)</td><td align="center">(2,1)</td><td align="center"><strong>(2,2)</strong></td><td align="center">(2,3)</td><td align="center">(2,4)</td></tr><tr><td align="center">(3,0)</td><td align="center">(3,1)</td><td align="center">(3,2)</td><td align="center">(3,3)</td><td align="center">(3,4)</td></tr><tr><td align="center">(4,0)</td><td align="center">(4,1)</td><td align="center">(4,2)</td><td align="center">(4,3)</td><td align="center">(4,4)</td></tr></tbody></table><p><strong>(2,2)为中心</strong></p><p>(1,2),(2,3),(3,2),(2,1)到中心的曼哈顿距离为1</p><p>依次类推</p><p>所以可以写出程序</p><h2 id="1-4-代码如下"><a href="#1-4-代码如下" class="headerlink" title="1.4 代码如下"></a>1.4 代码如下</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(i-m)+<span class="built_in">abs</span>(j-m)&lt;=m)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;*&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己报错两次,一次忘记输出空格了,一次if条件判断搞错了</p><h2 id="1-5-别人的题解"><a href="#1-5-别人的题解" class="headerlink" title="1.5 别人的题解"></a>1.5 别人的题解</h2><h3 id="1-5-1别人的曼哈顿距离解法"><a href="#1-5-1别人的曼哈顿距离解法" class="headerlink" title="1.5.1别人的曼哈顿距离解法"></a>1.5.1别人的曼哈顿距离解法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sx = n / <span class="number">2</span>, sy = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">abs</span>(sx - i) + <span class="built_in">abs</span>(sy - j) &lt;= n / <span class="number">2</span> ) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>他把中心点分为了两个坐标</p></blockquote><h3 id="1-5-2-暴力解法1"><a href="#1-5-2-暴力解法1" class="headerlink" title="1.5.2 暴力解法1"></a>1.5.2 暴力解法1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = n / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -x; i &lt;= x; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">abs</span>(i); j ++ ) cout &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="built_in">abs</span>(i) * <span class="number">2</span>; j ++ ) cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-暴力解法2"><a href="#1-5-3-暴力解法2" class="headerlink" title="1.5.3 暴力解法2"></a>1.5.3 暴力解法2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x - i; j ++ ) cout &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * i + <span class="number">1</span>; j ++  ) cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - x; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++ ) cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">2</span> * i; j ++ ) cout &lt;&lt; <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-暴力解法3"><a href="#1-5-4-暴力解法3" class="headerlink" title="1.5.4 暴力解法3"></a>1.5.4 暴力解法3</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> x = n / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> s[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入空格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            s[i][j] = <span class="string">&#x27; &#x27;</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上半部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = x - i; j &lt;= x + i; j ++ )</span><br><span class="line">            s[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中间一行  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">        s[x][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下半部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - x; j &lt; n - i + x; j ++ )</span><br><span class="line">            s[i][j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cout &lt;&lt; s[i][j] ;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-质数"><a href="#2-质数" class="headerlink" title="2. 质数"></a>2. 质数</h1><h2 id="2-1-算法思想"><a href="#2-1-算法思想" class="headerlink" title="2.1 算法思想"></a>2.1 算法思想</h2><h2 id="2-2-代码如下"><a href="#2-2-代码如下" class="headerlink" title="2.2 代码如下"></a>2.2 代码如下</h2><h3 id="2-2-1-最蠢的暴力解法"><a href="#2-2-1-最蠢的暴力解法" class="headerlink" title="2.2.1 最蠢的暴力解法"></a>2.2.1 最蠢的暴力解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(n%i == <span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not prime&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-2-优化一点的暴力解法"><a href="#2-2-2-优化一点的暴力解法" class="headerlink" title="2.2.2 优化一点的暴力解法"></a>2.2.2 优化一点的暴力解法</h3><p>少判断一半的数,因为其因数不可能大于他的一半</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(n%i == <span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not prime&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3-根号法"><a href="#2-2-3-根号法" class="headerlink" title="2.2.3 根号法"></a>2.2.3 根号法</h3><p>**一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)**，据此，上述代码中并不需要遍历到n-1，遍历到sqrt(n)即可，因为若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(n%i == <span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not prime&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-4-质数分布的规律"><a href="#2-2-4-质数分布的规律" class="headerlink" title="2.2.4 质数分布的规律"></a>2.2.4 质数分布的规律</h3><p><strong>一个关于质数分布的规律：大于等于5的质数一定和6的倍数相邻。例如5和7，11和13,17和19等等；</strong></p><p>这个代码就不给出来了</p><h1 id="3-完全数"><a href="#3-完全数" class="headerlink" title="3. 完全数"></a>3. 完全数</h1><h2 id="3-1-算法思想"><a href="#3-1-算法思想" class="headerlink" title="3.1 算法思想"></a>3.1 算法思想</h2><p>关键还是怎么求出他的因数,但是如果是一个数是完全平方数,我下面给出的代码好像不能完全判断,但是我这个代码考研AC,我认为要加一个完全平方数的判断条件,然后排除那个相同的因数</p><h2 id="3-2-代码如下"><a href="#3-2-代码如下" class="headerlink" title="3.2 代码如下"></a>3.2 代码如下</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin&gt;&gt;m;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">sqrt</span>(m);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m%i==<span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                sum += m/i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum/<span class="number">2</span> == m)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is perfect\n&quot;</span>,m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d not perfect\n&quot;</span>,m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-别人的代码"><a href="#3-3-别人的代码" class="headerlink" title="3.3 别人的代码"></a>3.3 别人的代码</h2><h3 id="3-3-1-利用完全数的性质"><a href="#3-3-1-利用完全数的性质" class="headerlink" title="3.3.1 利用完全数的性质"></a>3.3.1 利用完全数的性质</h3><p><strong>其实 100000000内的完全数没有几个</strong></p><p>100000000内的完全数有且仅有 <strong>6,28,496,8128,33550336</strong> 这五个.<br>根据上述内容, 这道题可以直接 O(1)解决.<br>完全数比较重要的几个性质</p><p>所有完全数都是三角形数<br>目前截止发现的<strong>所有完全数都以 6或 28结尾</strong><br>到现在为止,数学家们<strong>一共发现了 48个完全数,且 48个完全数全部是偶数</strong><br>如果有人们没有找到的奇完全数,则它一定可以写成 12p+1或 36p+9 的形式,而且 p是素数<br>奇完全数一定大于 10300<br>完全数的约数的倒数之和为调和数<br>完全数可以表示成连续奇数的立方和<br>完全数可以表示成 2的连续自然数的次幂之和,且这些自然数的数量必定是素数</p><p>完全数计算法</p><p>若<br>$$<br>2^p -1<br>$$<br>是素数(亦称其为梅森素数),则<br>$$<br>2^{p−1}∗(2^p−1)<br>$$<br> 是完全数.</p><h3 id="3-3-2-代码如下"><a href="#3-3-2-代码如下" class="headerlink" title="3.3.2 代码如下"></a>3.3.2 代码如下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">6</span> || n == <span class="number">28</span> || n == <span class="number">496</span> || n == <span class="number">8128</span> || n == <span class="number">33550336</span>)  </span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; is perfect&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; n &lt;&lt; <span class="string">&quot; is not perfect&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-蛇形矩阵"><a href="#4-蛇形矩阵" class="headerlink" title="4.蛇形矩阵"></a>4.蛇形矩阵</h1><blockquote><p>这道题我大一就没有解决,一直没有思路,别人的代码也看不懂</p></blockquote><h2 id="4-1-算法思想"><a href="#4-1-算法思想" class="headerlink" title="4.1 算法思想"></a>4.1 算法思想</h2><h2 id="4-2-自己的代码"><a href="#4-2-自己的代码" class="headerlink" title="4.2 自己的代码"></a>4.2 自己的代码</h2><blockquote><p>报错了,太难了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    cin &gt;&gt; m,n;</span><br><span class="line">    <span class="keyword">int</span> a[m][n];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">0</span>,left=<span class="number">0</span>,right=n<span class="number">-1</span>,bottom=m<span class="number">-1</span>,nums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top &lt;= bottom &amp;&amp; right &gt;= left)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;right;i++)&#123;</span><br><span class="line">            a[top][i]=nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=top+<span class="number">1</span>;i&lt;bottom;i++)&#123;</span><br><span class="line">            a[i][right]=nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=right<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            a[bottom][i]=nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=bottom<span class="number">-1</span>;i&gt;top+<span class="number">1</span>;i--)&#123;</span><br><span class="line">            a[i][left]=nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;left++;right--;bottom--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-别人的正确代码"><a href="#4-3-别人的正确代码" class="headerlink" title="4.3 别人的正确代码"></a>4.3 别人的正确代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = m - <span class="number">1</span>, top = <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left ; i &lt;= right; i ++) &#123;</span><br><span class="line">            a[top][i] = k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i ++) &#123;</span><br><span class="line">            a[i][right] = k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left &amp;&amp; top &lt; bottom; i --) &#123;</span><br><span class="line">            a[bottom][i] = k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top &amp;&amp; left &lt; right; i --) &#123;</span><br><span class="line">            a[i][left] = k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++, right --, top ++, bottom --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j ++) &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-自己和别人正确的代码对比"><a href="#4-4-自己和别人正确的代码对比" class="headerlink" title="4.4 自己和别人正确的代码对比"></a>4.4 自己和别人正确的代码对比</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;right<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    a[top][i]=nums++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left ; i &lt;= right; i ++) &#123;</span><br><span class="line">    a[top][i] = k ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自己的代码确实有问题,自己出错的原因是只画了4*4的矩阵,没有考虑3*7之类的,画一个行和列差别很大的矩阵,一下就迎刃而解了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=right<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    a[bottom][i]=nums++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left &amp;&amp; top &lt; bottom; i --) &#123;</span><br><span class="line">    a[bottom][i] = k ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>把矩阵画大一点,就很容易看出了,至于top&lt;bottom我感觉没有必要带上去</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=bottom<span class="number">-1</span>;i&gt;top+<span class="number">1</span>;i--)&#123;</span><br><span class="line">    a[i][left]=nums++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top &amp;&amp; left &lt; right; i --) &#123;</span><br><span class="line">    a[i][left] = k ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>top+1 就是画蛇添足了,至于left &lt; right我感觉没有必要带上去</p></blockquote><p>自己实测发现确实考研不用带上去,但是为了跟保险,带上去,也是一个好习惯</p><h1 id="5-斐波拉契数列"><a href="#5-斐波拉契数列" class="headerlink" title="5.斐波拉契数列"></a>5.斐波拉契数列</h1><h2 id="5-1-算法思想"><a href="#5-1-算法思想" class="headerlink" title="5.1 算法思想"></a>5.1 算法思想</h2><p><strong>递归</strong></p><h2 id="5-2-代码"><a href="#5-2-代码" class="headerlink" title="5.2 代码"></a>5.2 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fb</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>||n==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fb</span>(n<span class="number">-1</span>)+<span class="built_in">fb</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2022年2月24号</p><hr><h1 id="平方矩阵"><a href="#平方矩阵" class="headerlink" title="平方矩阵"></a>平方矩阵</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>在于对空格个数和换行个数的控制,我本来以为2^3的表示就是为2^3结果不是这样是pow函数,还有一点就是while循环和while do循环的区别,最后的临界调节到底执不执行</p><h2 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">int</span> a[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                a[i][j]=<span class="built_in">pow</span>(<span class="number">2</span>,(i+j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (j == n<span class="number">-1</span>)&#123;</span><br><span class="line">                    cout&lt;&lt;a[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                     cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="别人的优秀代码"><a href="#别人的优秀代码" class="headerlink" title="别人的优秀代码"></a>别人的优秀代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n+i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x=<span class="built_in">pow</span>(<span class="number">2</span>,j<span class="number">-1</span>);</span><br><span class="line">                cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>cin&gt;&gt;n &amp;&amp; n!=0,在while的判断条件里面加上这个,就可以不用在后面防止多出一个换行,他这个考虑的就是每一行的幂加一,我感觉我的方法比他更好</p></blockquote><h1 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h1><p>这段默认的结构体是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Res</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">   <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="vector数组"><a href="#vector数组" class="headerlink" title="vector数组"></a>vector数组</h2><p><code>#include&lt;vector&gt;</code></p><p>==vector是变长数组,支持随机访问==当vector发现空间不足时,是去倍增式的增加空间,vector怎么动态增空间的呢,倍增的思想,用多少开多少,不支持任意位置O(1)插入</p><h3 id="vector数组有三大种定义方式"><a href="#vector数组有三大种定义方式" class="headerlink" title="vector数组有三大种定义方式"></a>vector数组有三大种定义方式</h3><ol><li>一维数组:<code>vector&lt;int&gt; a</code></li><li>二维数组:<code>vector&lt;int&gt; b[223]</code>第一维静态的.第二维动态的</li><li>把结构体放进去<code>vector&lt;Res&gt; c</code></li></ol><h3 id="vector的函数"><a href="#vector的函数" class="headerlink" title="vector的函数"></a>vector的函数</h3><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p>a.size //所有的STL库都有</p><p>返回a的长度是多少</p><h4 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h4><p>a.empty();  //所有的STL库都有</p><p>判断a是否为空</p><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p>a.clear()</p><p>数组全部清空</p><h4 id="a-front"><a href="#a-front" class="headerlink" title="a.front()"></a>a.front()</h4><p>返回vector第一个元素 == a[0] == *a.begin()</p><h4 id="a-back"><a href="#a-back" class="headerlink" title="a.back()"></a>a.back()</h4><p>返回数组最后一个元素 == a[a.size()-1];</p><p>注意back()和end()的区别</p><h4 id="a-push-back-1"><a href="#a-push-back-1" class="headerlink" title="a.push_back(1)"></a>a.push_back(1)</h4><p>在数组的最后一个位置添加一个元素1,时间复杂度是O(1)</p><h4 id="a-pop-back"><a href="#a-pop-back" class="headerlink" title="a.pop_back()"></a>a.pop_back()</h4><p>删除最后一个元素,O(1)</p><h3 id="vector的三种迭代方式"><a href="#vector的三种迭代方式" class="headerlink" title="vector的三种迭代方式"></a>vector的三种迭代方式</h3><h4 id="迭代器-绝大多数情况都不用-比较麻烦"><a href="#迭代器-绝大多数情况都不用-比较麻烦" class="headerlink" title="迭代器(绝大多数情况都不用,比较麻烦)"></a>迭代器(绝大多数情况都不用,比较麻烦)</h4><p>假设vector赋值为</p><p><code>vector&lt;int&gt; a(&#123;1,2,3&#125;);</code></p><p>可以定义一个迭代器,支持相加减</p><p><code>vector&lt;int&gt;::iterator it = a.begin()</code></p><p>[a.begin();a.end();)左闭右开,[ )就像这样,end()是数组最后一个元素的下一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>();i!=a.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">//这里这个条件蛮帅的</span></span><br><span class="line"><span class="comment">//it+2 == a[2];当成指针来看,end是最后一个位置的下一个位置&#x27;*a.begin()</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>();i&lt;a.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>();i!=a.<span class="built_in">end</span>();i++) cout &lt;&lt; *i &lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">//可以用auto(更简便) //对于为什么*来取值,因为是指针</span></span><br></pre></td></tr></table></figure><mark class="hl-label yellow">迭代器相当于动态数组,和java的Array_list是一样的,绝大部分情况下不会用迭代器</mark> <h4 id="普通数组遍历方式-常用的方式"><a href="#普通数组遍历方式-常用的方式" class="headerlink" title="普通数组遍历方式(常用的方式)"></a>普通数组遍历方式(常用的方式)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++) cout &lt;&lt; a[i];</span><br></pre></td></tr></table></figure><h4 id="相当于String的那种遍历方式-也蛮常用的"><a href="#相当于String的那种遍历方式-也蛮常用的" class="headerlink" title="相当于String的那种遍历方式(也蛮常用的)"></a>相当于String的那种遍历方式(也蛮常用的)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c : a) cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>vector删除中间元素,用不到O(n),不用了解这个函数</p><h3 id="还支持比较的-字典序"><a href="#还支持比较的-字典序" class="headerlink" title="还支持比较的(字典序)"></a>还支持比较的(字典序)</h3><h2 id="普通-循环-队列"><a href="#普通-循环-队列" class="headerlink" title="普通(循环)队列"></a>普通(循环)队列</h2><p><code>#include&lt;queue&gt;</code></p><p>顺序:<mark class="hl-label red">先进先出</mark> </p><p>普通队列是循环队列queue,和现存的有关,和插入的元素无关</p><h3 id="普通队列的两大定义"><a href="#普通队列的两大定义" class="headerlink" title="普通队列的两大定义"></a>普通队列的两大定义</h3><ol><li>queue<int> q;</li><li>queue<double> a;</li><li>queue<Rec> w;</li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p>d.push({1,2}); </p><p><code>q.push(1); </code>在队头插入一个元素</p><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p><code>q.pop();</code>弹出队尾元素</p><h4 id="front"><a href="#front" class="headerlink" title="front()"></a>front()</h4><p><code>q.front();</code>返回队头</p><h4 id="back"><a href="#back" class="headerlink" title="back()"></a>back()</h4><p><code>q.back();</code>返回队尾</p><p>==只能队尾弹出,对头插入== </p><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p><code>#include&lt;queue&gt;</code></p><p>==会优先往外弹这堆数的最大值==</p><h3 id="普通队列的三大定义"><a href="#普通队列的三大定义" class="headerlink" title="普通队列的三大定义"></a>普通队列的三大定义</h3><ol><li><p>大根堆优先队列(重载小于号)</p><p><code>priority_queue&lt;int&gt;  a;</code> </p></li><li><p>小根堆优先队列(重载大于号)</p><p><code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; b; </code></p></li><li><p>结构体</p><p><code>priority_queue&lt;Rec&gt;  d;</code></p><p>这里另有说法,因为需要弹出最大或者最小值.所以需要比较大小,<mark class="hl-label yellow">需要重载大于号或者小于号</mark> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Rec&amp; t) <span class="keyword">const</span>&#123;</span><br><span class="line">rerturn a &lt;t.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载一下大小于号,优先级队列才不会报错,==优先队列重载小于号,小根堆重载大于号==</p></li></ol><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><h4 id="push-1"><a href="#push-1" class="headerlink" title="push()"></a>push()</h4><p><code>a.push(1);</code>插入一个元素,位置不确定</p><h4 id="top"><a href="#top" class="headerlink" title="top()"></a>top()</h4><p><code>a.top();</code>取出最大值</p><h4 id="pop-1"><a href="#pop-1" class="headerlink" title="pop()"></a>pop()</h4><p><code>a.pop();</code>删除最大值</p><blockquote><p>唯独3个STL没有clear()函数,队列,优先队列列和栈</p><p>那么怎么清空队列呢,初始化一下,就可以清空</p></blockquote><h2 id="栈-队尾插入-队头弹出"><a href="#栈-队尾插入-队头弹出" class="headerlink" title="栈(队尾插入,队头弹出)"></a>栈(队尾插入,队头弹出)</h2><p>==后进先出==</p><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><p><code>stack&lt;int&gt; stk;</code></p><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><h4 id="push-2"><a href="#push-2" class="headerlink" title="push()"></a>push()</h4><p><code>stk.push(1);</code>//插入一个元素</p><h4 id="pop-2"><a href="#pop-2" class="headerlink" title="pop()"></a>pop()</h4><p><code>stk.pop();</code>//删除栈顶元素</p><h4 id="top-1"><a href="#top-1" class="headerlink" title="top()"></a>top()</h4><p><code>stk.top();</code> //返回栈顶元素</p><h2 id="双端队列-和vector对比"><a href="#双端队列-和vector对比" class="headerlink" title="双端队列(和vector对比)"></a>双端队列(和vector对比)</h2><p><code>#include&lt;deque&gt;</code></p><p>==头尾都可以插入和删除==,都是O(1),平均来看,比vector和栈慢很多</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>deque<int> a;</p><h3 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h3><h4 id="a-begin-和vector一样的"><a href="#a-begin-和vector一样的" class="headerlink" title="a.begin() //和vector一样的"></a>a.begin() //和vector一样的</h4><h4 id="a-end"><a href="#a-end" class="headerlink" title="a.end()"></a>a.end()</h4><h4 id="a-front-1"><a href="#a-front-1" class="headerlink" title="a.front()"></a>a.front()</h4><h4 id="a-back-1"><a href="#a-back-1" class="headerlink" title="a.back()"></a>a.back()</h4><h4 id="a-push-back-1-1"><a href="#a-push-back-1-1" class="headerlink" title="a.push_back(1)"></a>a.push_back(1)</h4><p>结尾插入一个元素</p><h4 id="a-push-front-1"><a href="#a-push-front-1" class="headerlink" title="a.push_front(1)"></a>a.push_front(1)</h4><p>开头插入一个元素</p><h4 id="a-0"><a href="#a-0" class="headerlink" title="a[0]"></a>a[0]</h4><p>a[1]</p><p>随机访问一个元素;</p><h4 id="a-pop-back-1"><a href="#a-pop-back-1" class="headerlink" title="a.pop_back()"></a>a.pop_back()</h4><p>弹出最后一个元素</p><h4 id="a-pop-front"><a href="#a-pop-front" class="headerlink" title="a.pop_front()"></a>a.pop_front()</h4><p>弹出第一个元素</p><h4 id="a-clear"><a href="#a-clear" class="headerlink" title="a.clear()"></a>a.clear()</h4><p>清空队列</p><mark class="hl-label yellow">队列和堆原理基本上完全不一样,队列是用堆实现的</mark> <h2 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h2><p>#include<set> </p><mark class="hl-label yellow">底层实现是红黑树,动态维护一个有序集合,里面不能包含重复元素,如果元素重复,会被忽略</mark> <p><strong>multiset可以重复元素</strong></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>需要重载小于号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Rec&amp; t) <span class="keyword">const</span>&#123;</span><br><span class="line">rerturn a &lt;t.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set&lt;Rec&gt; a;</code></p><h3 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h3><h4 id="size-1"><a href="#size-1" class="headerlink" title="size()"></a>size()</h4><p><code>a.size()</code></p><h4 id="empty-1"><a href="#empty-1" class="headerlink" title="empty()"></a>empty()</h4><p><code>a.empty()</code></p><h4 id="clear-1"><a href="#clear-1" class="headerlink" title="clear()"></a>clear()</h4><p><code>a.clear()</code></p><h4 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h4><p><code>a.end()</code>最后一个元素的后一个位置</p><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p><code>a.insert(X);</code> 插入一个X</p><h4 id="lower-bound-x"><a href="#lower-bound-x" class="headerlink" title="lower_bound(x)"></a>lower_bound(x)</h4><p><code>a.lower_bound(x) </code>//找到<mark class="hl-label red">大于等于</mark> x的最小的元素的迭代器</p><h4 id="upper-bound-x"><a href="#upper-bound-x" class="headerlink" title="upper_bound(x)"></a>upper_bound(x)</h4><p><code>a.upper_bound(x)</code>//找到大于x的最小的元素的迭代器</p><h4 id="count-x"><a href="#count-x" class="headerlink" title="count(x)"></a>count(x)</h4><p><code>a.count(x)</code>;x在a中的个数,在multiset里面的个数可能大于1</p><h4 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h4><p>a.erase(x);删掉所有等于x的所有元素</p><h3 id="迭代器-理解为指针"><a href="#迭代器-理解为指针" class="headerlink" title="迭代器(理解为指针)"></a>迭代器(理解为指针)</h3><p>set里面也有迭代器,set里面的++,– 比较复杂</p><p><code>set&lt;int&gt;::iterator it = a.begin();</code></p><p><code>it++;</code>(红黑树里面找前驱或者后继)log(n)</p><h4 id="迭代器的应用"><a href="#迭代器的应用" class="headerlink" title="迭代器的应用"></a>迭代器的应用</h4><p>返回一个X的迭代器,判断一个元素在a中是否存在</p><p>if(a.find(X) == a.end())  假设没有找到返回a.end(),假设找到了,会返回X的迭代器</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>#include&lt;map&gt;</code></p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><h4 id="map-lt-int-int-gt-a"><a href="#map-lt-int-int-gt-a" class="headerlink" title="map&lt;int,int&gt; a"></a>map&lt;int,int&gt; a</h4><p>用法和数组差不多</p><p>a[1] = 2;</p><p>a[100000] = 3;</p><h4 id="map-lt-String-int-gt"><a href="#map-lt-String-int-gt" class="headerlink" title="map&lt;String,int&gt;"></a>map&lt;String,int&gt;</h4><p>a[“liqin”] = 6;</p><h4 id="map-lt-String-vector-gt-a"><a href="#map-lt-String-vector-gt-a" class="headerlink" title="map&lt;String,vector&gt; a;"></a>map&lt;String,vector<int>&gt; a;</h4><p>a[“yxc”] = vector<int>({1,2,3,4});</p><p>a[“yxc”] [2] == 3;</p><h3 id="函数-5"><a href="#函数-5" class="headerlink" title="函数"></a>函数</h3><h4 id="insert-1"><a href="#insert-1" class="headerlink" title="insert"></a>insert</h4><p>a.insert({“a”,{}});</p><p>a.find(“yxc”)   == a.end()//找是否存在这个lkey</p><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><p>#include<unordered_set> //无序的set,不能存储重复元素</p><p>底层实现是hash表,时间复杂度为O(1)</p><p>和set完全一样(除了lower_bound(x)和upper_bound(x),不支持二分)</p><p>unordered_multiset<int> b;//哈希表,可以存储重复元素</p><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>unordered_map&lt;int,int&gt; c;</p><p>O(1)</p><p>坏处是不能支持二分,不过只有c++11支持,但是不会用来做二分的</p><h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h2><p><code>#include&lt;bitset&gt;</code></p><p>bitset&lt;1000&gt; a;长度为1000的0,1串</p><p>a[0] = 1;</p><p>a[1] = 0;</p><p>a &amp;= b;位运算</p><p>a.set(3) 第三位设成1</p><p>a.reset(3) 第三位设成0</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>pair支持比较运算,字典序,关键是背下来</p><p>pair&lt;int,string&gt; a;</p><p>cout &lt;&lt; a.first &lt;&lt;” “ &lt;&lt;a.second &lt;&lt;endl;</p>]]></content>
      
      
      <categories>
          
          <category> Acwing </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acwing </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-Mysql数据库</title>
      <link href="/2022/02/09/03-Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/02/09/03-Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-初识MySQL"><a href="#1-初识MySQL" class="headerlink" title="1. 初识MySQL"></a>1. 初识MySQL</h1><blockquote><p>只会写代码的是码农；学好数据库，基本能混口饭吃；在此基础上再学好操作系统和计算机网络，就能当一个不错的程序员。如果能再把离散数学、数字电路、体系结构、数据结构/算法、编译原理学通透，再加上丰富的实践经验与领域特定知识，就能算是一个优秀的工程师了。</p></blockquote><h2 id="1-1-为什么学习数据库"><a href="#1-1-为什么学习数据库" class="headerlink" title="1.1 为什么学习数据库"></a>1.1 为什么学习数据库</h2><p>1、岗位技能需求</p><p>2、现在的世界,得数据者得天下</p><p>3、存储数据的方法</p><p>4、程序,网站中,大量数据如何长久保存? </p><p>5、<strong>数据库是几乎软件体系中最核心的一个存在。</strong></p><h2 id="1-2-什么是数据库"><a href="#1-2-什么是数据库" class="headerlink" title="1.2 什么是数据库"></a>1.2 什么是数据库</h2><p>数据库 ( <strong>DataBase</strong> , 简称<strong>DB</strong> )</p><p><strong>概念</strong> : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库”</p><p><strong>作用</strong> : 保存,并能安全管理数据(如:增删改查等),减少冗余…</p><p><strong>数据库总览</strong> <strong>:</strong></p><ul><li>关系型数据库 ( SQL )</li></ul><p>MySQL , Oracle , SQL Server , SQLite , DB2 , …</p><p>关系型数据库通过外键关联来建立表与表之间的关系 ,学员信息表,考勤表</p><ul><li>非关系型数据库 ( NOSQL )not only sql</li></ul><p>Redis , MongoDB , …</p><p>非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定,定位信息表,动态更新</p><h2 id="1-3-什么是DBMS"><a href="#1-3-什么是DBMS" class="headerlink" title="1.3 什么是DBMS"></a>1.3 什么是DBMS</h2><p>数据库管理系统 ( <strong>D</strong>ata<strong>B</strong>ase <strong>M</strong>anagement <strong>S</strong>ystem )</p><p>数据库管理软件 , 科学组织和存储数据 , 高效地获取和维护数据</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-02-09_11-27-04.png" alt="Snipaste_2022-02-09_11-27-04"></p><h1 id="2-操作数据库"><a href="#2-操作数据库" class="headerlink" title="2.操作数据库"></a>2.操作数据库</h1><h2 id="2-1-基本的命令行操作"><a href="#2-1-基本的命令行操作" class="headerlink" title="2.1 基本的命令行操作"></a>2.1 基本的命令行操作</h2><p>连接数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -psecqin  --连接数据库</span><br></pre></td></tr></table></figure><p>修改用户密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user <span class="built_in">set</span> authentication_string=password(<span class="string">&#x27;123456&#x27;</span>) <span class="built_in">where</span> user=<span class="string">&#x27;root&#x27;</span> and Host = <span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><p>刷新权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>所有的语句分号结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases; 显示所有数据库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use dbname； 切换数据库</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables; 显示选中数据库中所有的表</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe user; 显示表mysql数据库中user表的列信息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database name; 创建数据库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exit; 退出Mysql</span><br><span class="line">? 命令关键词 : 寻求帮助</span><br><span class="line">-- 表示注释,单行注释(SQL本来的注释)</span><br><span class="line">/*</span><br><span class="line">SQL的多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>数据库xxx语言 CRUD 增删改查!!!   CV程序猿     API程序猿       CRUD程序猿(业务!)</p><p>DDL(定义)</p><p>DML(操作)</p><p>DQL(查询)</p><p>DCL(控制)</p><p><img src="https://gitee.com/secqin/img/raw/master/img/123.png" alt="123"></p><p>mysql关键字不区分大小写</p><h2 id="2-2-数据库操作"><a href="#2-2-数据库操作" class="headerlink" title="2.2 数据库操作"></a>2.2 数据库操作</h2><h4 id="命令行操作数据库"><a href="#命令行操作数据库" class="headerlink" title="命令行操作数据库"></a>命令行操作数据库</h4><p>创建数据库 : create database [if not exists] 数据库名;</p><p>删除数据库 : drop database [if exists] 数据库名;</p><p>查看数据库 : show databases;</p><p>使用数据库 : use `数据库名`;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``:在tab键的上方</span><br></pre></td></tr></table></figure><h2 id="2-3-列的数据类型讲解"><a href="#2-3-列的数据类型讲解" class="headerlink" title="2.3 列的数据类型讲解"></a>2.3 列的数据类型讲解</h2><blockquote><p>数值类型</p></blockquote><p><img src="https://gitee.com/secqin/img/raw/master/img/9eb50c783e0bb3da8bbbea8701815b1e.png" alt="9eb50c783e0bb3da8bbbea8701815b1e"></p><blockquote><p>字符串类型</p></blockquote><p><img src="https://gitee.com/secqin/img/raw/master/img/baf75f3c71d91173305f13fefe552e96.png" alt="img"></p><blockquote><p>日期和时间型数值类型</p></blockquote><p>java.util.Date</p><ul><li>date YYYY-MM-DD,日期格式</li><li>time HH:mm:ss 时间格式</li><li><strong>datetime YYYY-MM-DD HH:mm:ss(最常用的时间格式)</strong></li><li><strong>timestamp 时间戳,1970.1.1到现在的毫秒数(也较为常用)</strong></li><li>year 年份表示</li></ul><p><img src="https://gitee.com/secqin/img/raw/master/img/0c01a1b5a1cd1e11386bcb8da7f18af6.png" alt="img"></p><blockquote><p>NULL值</p></blockquote><ul><li><p>理解为 “没有值” 或 “未知值”</p></li><li><p>注意:不要用NULL进行算术运算(不是不能使用) , 结果仍为NULL,相当于0*0=0</p></li></ul><h2 id="2-4-数据库的字段属性"><a href="#2-4-数据库的字段属性" class="headerlink" title="2.4 数据库的字段属性"></a>2.4 数据库的字段属性</h2><h3 id="数据字段属性"><a href="#数据字段属性" class="headerlink" title="数据字段属性"></a>数据字段属性</h3><p><strong>UnSigned</strong></p><ul><li>无符号的</li><li>声明该数据列不允许负数 .</li></ul><p><strong>ZEROFILL</strong></p><ul><li>0填充的</li><li>不足位数的用0来填充 , 如int(3),5则为005</li></ul><p><strong>Auto_InCrement</strong></p><ul><li>自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认)</li><li>通常用于设置<strong>主键</strong> , 且必须为整数类型</li><li>可定义起始值和步长</li><li><ul><li>当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表</li><li> SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局)</li></ul></li></ul><p><strong>NULL 和 NOT NULL</strong></p><ul><li>默认为NULL , 即没有插入该列的数值</li><li>如果设置为NOT NULL , 则该列必须有值</li></ul><p><strong>DEFAULT</strong></p><ul><li>默认的</li><li>用于设置默认值</li><li>例如,性别字段,默认为”男” , 否则为 “女” ; 若无指定该列的值 , 则默认值为”男”的值</li><li>每一个表都必须存在一下5个字段!未来做项目用的,表示一个记录存在的意义</li></ul><p>id</p><p>`VERSION` 乐观锁</p><p>is_delete 伪删除</p><p>gmt_create 创建时间</p><p>gmt_update 修改时间 </p><p>拓展:听听就好</p><h2 id="2-4-创建数据表-重点"><a href="#2-4-创建数据表-重点" class="headerlink" title="2.4 创建数据表(重点)"></a>2.4 创建数据表(重点)</h2><p>属于DDL的一种，语法 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table [if not exists] `表名`(</span><br><span class="line">   &#x27;字段名1&#x27; 列类型 [属性][索引][注释],</span><br><span class="line">   &#x27;字段名2&#x27; 列类型 [属性][索引][注释],</span><br><span class="line">  #...</span><br><span class="line">   &#x27;字段名n&#x27; 列类型 [属性][索引][注释]</span><br><span class="line">)[表类型][表字符集][注释];</span><br></pre></td></tr></table></figure><p><strong>说明 :</strong> 反引号(反单引号)用于区别MySQL保留字与普通字符而引入的 (键盘tab上面的键).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 目标 : 创建一个school数据库</span><br><span class="line">-- 创建学生表(列,字段)</span><br><span class="line">-- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,email</span><br><span class="line">-- 创建表之前 , 一定要先选择数据库</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS `student` (</span><br><span class="line">`id` int(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;, -- 自增</span><br><span class="line">`name` varchar(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;, -- 默认值,非空</span><br><span class="line">`pwd` varchar(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,</span><br><span class="line">`sex` varchar(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`birthday` datetime DEFAULT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`address` varchar(100) DEFAULT NULL COMMENT &#x27;地址&#x27;,</span><br><span class="line">`email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line"></span><br><span class="line">-- 查看数据库的定义</span><br><span class="line">SHOW CREATE DATABASE school;</span><br><span class="line">-- 查看数据表的定义</span><br><span class="line">SHOW CREATE TABLE student;</span><br><span class="line">-- 显示表结构</span><br><span class="line">DESC student;  -- 设置严格检查模式(不能容错了)SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;;</span><br></pre></td></tr></table></figure><p>SHOW CREATE DATABASE school –查看创建数据库的语句</p><p>SHOW CREATE TABLE student – 查看student数据库的定义语句 </p><p>DESC student – 显示表的结构</p><h2 id="2-5-数据表的类型"><a href="#2-5-数据表的类型" class="headerlink" title="2.5 数据表的类型"></a>2.5 数据表的类型</h2><p>数据库引擎:ENGINE=InnoDB</p><p>InnoDB  默认使用~</p><p>MYISAM 早些年使用</p><table><thead><tr><th></th><th>MYISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间的大小</td><td>较小</td><td>较大,约为2倍</td></tr></tbody></table><p>常规操作</p><ul><li>MYISAM 节约空间,速度较快</li><li>INNODB 安全性高,事务的处理,多表多用户操作</li></ul><blockquote><p>物理空间存在的位置</p></blockquote><p>所有数据库文件存在data目录下,一个文件夹对应一个数据库</p><p>本质还是文件的存储</p><p>MySQL引擎在物理文件上的区别 </p><ul><li>innoDB 在数据库表中只有一个*.frm文件,以及上级目录下的ibdata1文件</li><li>MYISAM对应的文件</li></ul><ol><li>*.frm -表结构的定义文件</li><li>*MYD 数据文件(data)</li><li>*.MYI 索引文件(index)</li></ol><blockquote><p>设置数据库表的字符集编码</p></blockquote><p>CHARSET=utf8</p><p>不设置就是默认字符集编码Latin1,不支持中文</p><p>在my.ini中配置默认编码</p><p>加上character-set-server=utf-8</p><h2 id="2-6-修改删除表"><a href="#2-6-修改删除表" class="headerlink" title="2.6 修改删除表"></a>2.6 修改删除表</h2><h4 id="2-6-1-修改表-ALTER-TABLE"><a href="#2-6-1-修改表-ALTER-TABLE" class="headerlink" title="2.6.1 修改表 ( ALTER TABLE )"></a>2.6.1 修改表 ( ALTER TABLE )</h4><p>修改表名 :ALTER TABLE 旧表名 RENAME AS 新表名</p><p>增加表的字段 : ALTER TABLE 表名 ADD字段名 列属性[属性]</p><p>修改表的字段 (重命名,修改约束):</p><ul><li>ALTER TABLE 表名 MODIFY 字段名 列类型[属性]   –修改约束</li><li>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性]   –重命名</li></ul><p><a href="https://blog.csdn.net/qq_36057860/article/details/79512394">change和modify的区别</a></p><p>删除字段 : ALTER TABLE 表名 DROP 字段名   </p><h4 id="2-6-2-删除数据表"><a href="#2-6-2-删除数据表" class="headerlink" title="2.6.2 删除数据表"></a>2.6.2 删除数据表</h4><p>语法：DROP TABLE [IF EXISTS] 表名</p><ul><li>IF EXISTS为可选 , 判断是否存在该数据表</li><li>如删除不存在的数据表会抛出错误</li></ul><p>所有的创建和删除尽量加上判断,避免报错</p><p><strong>注意点:</strong> </p><ul><li>`` 字段名,使用这个包裹!</li><li>注释 –</li><li>sql 关键字大小写不敏感,建议大家写小写,小写大家一定认识</li><li>所有符号全部用英文</li></ul><h1 id="3-MySQL数据管理"><a href="#3-MySQL数据管理" class="headerlink" title="3.MySQL数据管理"></a>3.MySQL数据管理</h1><h2 id="3-1-外键-了解即可"><a href="#3-1-外键-了解即可" class="headerlink" title="3.1 外键(了解即可)"></a>3.1 外键(了解即可)</h2><h4 id="外键概念"><a href="#外键概念" class="headerlink" title="外键概念"></a>外键概念</h4><p>如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为<strong>主表</strong>，具有此外键的表被称为主表的<strong>从表</strong>。</p><p>在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(<strong>foreign key</strong>)。</p><p><strong>外键作用</strong></p><p>保持数据<strong>一致性</strong>，<strong>完整性</strong>，主要目的是控制存储在外键表中的数据,<strong>约束</strong>。使两张表形成关联，外键只能引用外表中的列的值或使用空值。</p><h4 id="创建外键"><a href="#创建外键" class="headerlink" title="创建外键"></a>创建外键</h4><p>建表时指定外键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建外键的方式一 : 创建子表同时创建外键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 年级表 (id\年级名称)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `grade` (</span><br><span class="line">`gradeid` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;年级ID&#x27;</span>,</span><br><span class="line">`gradename` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年级名称&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`gradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">`studentno` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">`studentname` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;匿名&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`sex` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">`gradeid` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年级&#x27;</span>,</span><br><span class="line">`phoneNum` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机&#x27;</span>,</span><br><span class="line">`address` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">`borndate` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">`email` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">`idCard` <span class="type">VARCHAR</span>(<span class="number">18</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;身份证号&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`studentno`),</span><br><span class="line">KEY `FK_gradeid` (`gradeid`),</span><br><span class="line"><span class="keyword">CONSTRAINT</span> `FK_gradeid` <span class="keyword">FOREIGN</span> KEY (`gradeid`) REFE  RENCES `grade` (`gradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><blockquote><p>建表后修改  – 创建外键方式二 : 创建子表完毕后,修改子表添加外键 </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建外键方式二 : 创建子表完毕后,修改子表添加外键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student`</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> `FK_gradeid` <span class="keyword">FOREIGN</span> KEY (`gradeid`) <span class="keyword">REFERENCES</span> `grade` (`gradeid`)</span><br></pre></td></tr></table></figure><blockquote><p>删除具有主外键关系的表时 , 要先删子表 , 后删主表</p></blockquote><p>以上的操作都是物理（数据库）级别的外键，不建议使用（避免数据库过多造成困扰）</p><blockquote><p>最佳实践</p></blockquote><ul><li>數據庫就是單純的表，只又來存數據</li></ul><p><a href="https://www.cnblogs.com/rjzheng/p/9907304.html">为什么不用外键约束</a></p><h2 id="3-2-DML语言-全部记住"><a href="#3-2-DML语言-全部记住" class="headerlink" title="3.2 DML语言(全部记住)"></a>3.2 DML语言(全部记住)</h2><ul><li>insert</li><li>update</li><li>delete</li></ul><h2 id="3-3-添加-insert"><a href="#3-3-添加-insert" class="headerlink" title="3.3 添加(insert)"></a>3.3 添加(insert)</h2><blockquote><p>insert</p></blockquote><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名[(字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span>,...)] <span class="keyword">VALUES</span>(<span class="string">&#x27;值1&#x27;</span>,<span class="string">&#x27;值2&#x27;</span>,<span class="string">&#x27;值3&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>字段或值之间用英文逗号隔开 .</p></li><li><p>‘ 字段1,字段2…’ 该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致 .</p></li><li><p>可同时插入多条数据 , values 后用英文逗号隔开 .</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用语句如何增加语句?</span></span><br><span class="line"><span class="comment">-- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade(gradename) <span class="keyword">VALUES</span> (<span class="string">&#x27;大一&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主键自增,那能否省略呢?</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span> (<span class="string">&#x27;大二&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询:INSERT INTO grade VALUE (&#x27;大二&#x27;)错误代码：1136</span></span><br><span class="line"><span class="keyword">Column</span> count doesn`t <span class="keyword">match</span> <span class="keyword">value</span> count <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结论:&#x27;字段1,字段2...&#x27;该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 一次插入多条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade(gradename) <span class="keyword">VALUES</span> (<span class="string">&#x27;大三&#x27;</span>),(<span class="string">&#x27;大四&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="3-4-修改-update"><a href="#3-4-修改-update" class="headerlink" title="3.4 修改(update)"></a>3.4 修改(update)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 <span class="keyword">SET</span> column_name<span class="operator">=</span><span class="keyword">value</span> [,column_name2<span class="operator">=</span>value2,...] [<span class="keyword">WHERE</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>column_name 为要更改的数据列</li><li>value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果</li><li>condition 为筛选条件 , 如不指定则修改该表的所有列数据</li></ul><blockquote><p>where条件子句</p></blockquote><p>可以简单的理解为 : 有条件地从表中筛选数据<br><img src="https://gitee.com/secqin/img/raw/master/236898483c9b7e819df2fbd0152c7f8d.png" alt="img"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改年级信息</span></span><br><span class="line">UPDATE grade <span class="keyword">SET</span> gradename <span class="operator">=</span> <span class="string">&#x27;高中&#x27;</span> <span class="keyword">WHERE</span> gradeid <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="3-5-删除-delete"><a href="#3-5-删除-delete" class="headerlink" title="3.5 删除(delete)"></a>3.5 删除(delete)</h2><blockquote><p>delete命令</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：condition为筛选条件 , 如不指定则删除该表的所有列数据                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </p><p>– 删除最后一个数据DELETE FROM grade WHERE gradeid = 5                                                                                                                                                                                                                   </p><blockquote><p>TRUNCATE命令</p></blockquote><p>作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ;</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空年级表</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> grade</span><br></pre></td></tr></table></figure><p><strong>注意：区别于DELETE命令</strong></p><ul><li>相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快</li><li>不同 :</li><li><ul><li>使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器</li><li>使用TRUNCATE TABLE不会对事务有影响 （事务后面会说）</li></ul></li></ul><blockquote><p>测试</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`coll` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入几个测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test(coll) <span class="keyword">VALUES</span>(<span class="string">&#x27;row1&#x27;</span>),(<span class="string">&#x27;row2&#x27;</span>),(<span class="string">&#x27;row3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表数据(不带where条件的delete)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> test;</span><br><span class="line"><span class="comment">-- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表数据(truncate)</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> test;</span><br><span class="line"><span class="comment">-- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志.</span></span><br></pre></td></tr></table></figure><p>– 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后<br>– InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失)<br>– MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失)</p><h1 id="4-DQL查询语句-最重点"><a href="#4-DQL查询语句-最重点" class="headerlink" title="4.DQL查询语句(最重点)"></a>4.DQL查询语句(最重点)</h1><ul><li>查询数据库数据 , 如<strong>SELECT</strong>语句</li><li>简单的单表查询或多表的复杂查询和嵌套查询</li><li>是数据库语言中最核心,最重要的语句</li><li>使用频率最高的语句</li></ul><blockquote><p>select语法</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>]</span><br><span class="line">&#123;<span class="operator">*</span> <span class="operator">|</span> table.<span class="operator">*</span> <span class="operator">|</span> [table.field1[<span class="keyword">as</span> alias1][,table.field2[<span class="keyword">as</span> alias2]][,...]]&#125;</span><br><span class="line"><span class="keyword">FROM</span> table_name [<span class="keyword">as</span> table_alias]</span><br><span class="line">  [<span class="keyword">left</span> <span class="operator">|</span> <span class="keyword">right</span> <span class="operator">|</span> <span class="keyword">inner</span> <span class="keyword">join</span> table_name2]  <span class="comment">-- 联合查询</span></span><br><span class="line">  [<span class="keyword">WHERE</span> ...]  <span class="comment">-- 指定结果需满足的条件</span></span><br><span class="line">  [<span class="keyword">GROUP</span> <span class="keyword">BY</span> ...]  <span class="comment">-- 指定结果按照哪几个字段来分组</span></span><br><span class="line">  [<span class="keyword">HAVING</span>]  <span class="comment">-- 过滤分组的记录必须满足的次要条件</span></span><br><span class="line">  [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]  <span class="comment">-- 指定查询记录按一个或多个条件排序</span></span><br><span class="line">  [LIMIT &#123;[<span class="keyword">offset</span>,]row_count <span class="operator">|</span> row_countOFFSET <span class="keyword">offset</span>&#125;];</span><br><span class="line">   <span class="comment">-- 指定查询的记录从哪条至哪条</span></span><br></pre></td></tr></table></figure><p><strong>注意 : [ ] 括号代表可选的 , { }括号代表必选得</strong></p><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.事务</h1><p>要么都成功,要么都失败</p><hr><ol><li>sql执行 A给B转账 A 1000 –&gt;200 B 200</li><li>sql执行 B收到A的钱 A 800  –&gt;B 400</li></ol><hr><p>将一组sql放一个批次中去执行</p><blockquote><p>事务原则:ACID原则 原子性,一致性,隔离性,持久性(脏读,幻读…)</p></blockquote><p>原子性:针对同一个事物,一起成功,一起失败</p><p>一致性:最终一致性,总价是1000,无论怎么转,最后的值一定是1000</p><p>持久性:事务结束后的数据不会随外界原因导致数据包丢失,事务没有提交,恢复到原状,事务一但提交不可逆</p><p>隔离性:多个用户同时操作,</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-批处理</title>
      <link href="/2022/02/09/01-%E6%89%B9%E5%A4%84%E7%90%86%20/"/>
      <url>/2022/02/09/01-%E6%89%B9%E5%A4%84%E7%90%86%20/</url>
      
        <content type="html"><![CDATA[<blockquote><p>命令</p></blockquote><h1 id="1-常见cmd命令"><a href="#1-常见cmd命令" class="headerlink" title="1. 常见cmd命令"></a>1. 常见cmd命令</h1><ol><li><p><strong>dir</strong> 　　　列文件名 </p></li><li><p><strong>cd</strong>　　　　改变当前目录 </p></li><li><p><strong>ren</strong> 　　　改变文件名 </p></li><li><p><strong>copy</strong>　　　拷贝文件 </p></li><li><p><strong>del</strong> 　　　删除文件 </p></li><li><p><strong>md</strong>　　　　建立子目录 </p></li><li><p><strong>rd</strong>　　　　删除目录 </p></li><li><p><strong>deltree</strong>　 删除目录树 </p></li><li><p><strong>format</strong>　　格式化磁盘 </p></li><li><p><strong>edit</strong>　　　文本编辑 </p></li><li><p><strong>type</strong>　　　显示文件内容 </p></li><li><p><strong>mem</strong> 　　　查看内存状况 </p><p>以下是新增加的命令 </p></li><li><p><strong>help</strong>　　　显示帮助提示 </p></li><li><p><strong>cls</strong> 　　　清屏 </p></li><li><p><strong>move</strong>　　　移动文件，改目录名 </p></li><li><p><strong>more</strong>　　　分屏显示 </p></li><li><p><strong>xcopy</strong> 　　拷贝目录和文件</p></li></ol><p><strong>此时我们来尝试一下使用一些基本的DOS命令</strong><br>比如，键入 **dir (不区分大小写)**并按回车后，我们会得到当前文件夹下所有的子文件夹和文件的相关信息。输入 <strong>dir c:\windows</strong>  ，可以查看指定的路径文件夹(这里假定我们指定的文件夹是C盘的WINDOWS文件夹)中的信息。在输入该命令后，只见刷地一下啥也没看清，N多文件或文件夹就已一闪而过，因为一个屏幕无法显示这么多的文件或文件夹。好在在DOS5中我们可以用鼠标滚轮向前滚动查看更多的内容。然而，早期的DOS版本并不具有保存多页信息的功能，我们不妨使用 dir 的一些参数(适当的参数加在相应的命令后面可以实现更多的扩展功能)，比如 /p ，即输入 <strong>dir c:\windows /p</strong>  。这样就能在每显示一个屏幕的内容后暂停一下以便查看。 </p><p>只要输入 <strong>dir /?</strong> 就能得到关于dir命令完整的使用介绍，而且是中文的。同理，<strong>任何命令后面跟上 /? 的参数，都能得到该命令的完整说明</strong></p><p>输入 <strong>help dir</strong> 就能得到命令 dir 的具体参数及其用法(等同与 dir /? )</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li><p><strong>d:</strong> </p><p>转到驱动器D盘下，此时我们能看到 D:&gt; 的提示符(前提是您的电脑硬盘必须至少划分出D盘)。如果看到的不是就再输入下一行命令。 </p></li><li><p>*<em>cd\*</em> </p><p>这一条命令 cd 的作用是改变当前的工作目录，后面加上 \ 表示返回到该驱动器的最顶级目录。另外，一个句点 . 表示当前文件夹，两个连续的句点 .. 则表示上一级文件夹， cd.. 即目录向上一级。 </p></li><li><p><strong>md test</strong> </p><p>正如前文所说，命令 md 的作用是创建子目录，此时打开D盘看一看，是不是多了一个名叫test的文件夹(如果不是事先早已存在的话)。事实上该命令的完整写法为 md d:\test ，由于当前目录已经在D盘了，所以我们把具体的路径给简化了。 </p></li><li><p><strong>md “test my folder”</strong> </p><p>同理，在D盘创建一个名为test my  folder的文件夹。加双引号的目的是告诉计算机我们要创建一个名字中含有空格的文件夹，而不是分别创建名字分别为test、my和folder的3个不同的文件夹。注：除了空格以外，在路径或文件名中含有 &amp;()[]{}^=;!’+,`~ 特殊字符时也需要用双引号引用起来，以便机器能够正确地识别。 </p></li><li><p><strong>cd test</strong> </p><p>改变当前工作目录，此时不再是D盘了，而是在 D:\test 的目录下。 </p></li><li><p><strong>echo Hello world&gt;a.txt</strong> </p><p>遇到了一个新命令 echo ，它可以将某某内容显示出来。只考虑 echo Hello world 就是把字符串 Hello world  显示出来而已。后面使用了符号 &gt; 表示将这句 Hello world 写入到某文件中。结果为：在 D:\test 文件夹里多了一个叫  a.txt 的文件，其内容为 Hello world 。 </p></li><li><p><strong>copy a.txt “d:\test my folder”</strong> </p><p>这就是将当前文件夹里的那个 a.txt 文件复制到 D:\test my folder 文件夹中 </p></li><li><p><strong>copy a.txt “..\test my folder\b.txt”</strong> </p><p>还是复制 a.txt ，但这次的路径与上一条命令的写法不同。 .. 表示先向上一级，再挪到 test my folder  文件夹里。其实还是复制到 D:\test my folder  这个文件夹里了。这次复制过去的文件名也不一样，因为这次我们指定了要复制过去的目标文件名为 b.txt 。 </p></li><li><p><strong>copy a.txt “..\test my folder\c.bmp”</strong> </p><p>再次复制 a.txt 到同样的文件夹里。不过这次不光改文件的标题名了，连文件的后缀名也改了。打开 D:\test my folder 文件夹检查一下，是不是多了名字分别叫 a.txt b.txt c.bmp 的3个文件。 </p></li><li><p><strong>cd..</strong> </p><p>向上一级 </p></li><li><p><strong>cd “test my folder”</strong> </p><p>进入 D:\test my folder 文件夹 </p></li><li><p><strong>ren c.bmp d.bin</strong> </p><p>重新命名文件 c.bmp 为 d.bin 。完整地写法为 ren “d:\test my folder\c.bmp” d.bin 。 </p></li><li><p>*<em>del <em>.txt</em></em> </p><p>删除当前工作目录中所有文件后缀名为 .txt 的文件。 * 表示通配符。例如：a.* 表示所有文件标题为 a 的文件，不论后缀名。  <em>.</em> 则表示任何标题名和任何后缀名的文件，即所有文件。此时结果应为：该目录里的 a.txt b.txt  这两个文件已经不存在了，即使是在回收站里也找不到了。 </p></li><li><p><strong>cd..</strong> </p><p>向上一级 </p></li><li><p><strong>rd test “test my folder”</strong> </p><p>这一条命令是想同时移除 test 和 test my folder 这两个文件夹。不过结果并没有成功，因为它会提示：目录不是空的。test 文件夹中有 a.txt ，test my folder 文件夹中还有 d.bin ，因此文件夹删不掉。 </p></li><li><p><strong>rd test “test my folder” /s</strong> </p><p>如果加上 /s 这个参数后就能删除这两个文件夹以及其文件夹中所包含的所有内容了。注意：删除前请确认这些文件夹是否是您以前就有的文件夹，或者说里面是否存有任何有用文件，不要因为这个测试而丢掉了重要文件。 </p></li></ol><h1 id="2-我们的第一个批处理"><a href="#2-我们的第一个批处理" class="headerlink" title="2. 我们的第一个批处理"></a>2. 我们的第一个批处理</h1><ol><li><p>我们在桌面建一个文件MyFirstBatch.bat</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">md</span> &quot;d:\test&quot; &quot;d:\test my folder&quot;</span><br><span class="line"><span class="built_in">echo</span> Hello world&gt;&quot;d:\test\a.txt&quot;</span><br><span class="line"><span class="built_in">copy</span> &quot;d:\test\a.txt&quot; &quot;d:\test my folder&quot;</span><br><span class="line"><span class="built_in">copy</span> &quot;d:\test\a.txt&quot; &quot;d:\test my folder\b.txt&quot;</span><br><span class="line"><span class="built_in">copy</span> &quot;d:\test\a.txt&quot; &quot;d:\test my folder\c.bmp&quot;</span><br><span class="line"><span class="built_in">ren</span> &quot;d:\test my folder\c.bmp&quot; d.bin </span><br></pre></td></tr></table></figure></li></ol><p>双击后，显示的只是一闪就关闭了。正确的结果是在D盘多了名字分别为 test 和 test my folder 的两个文件夹。文件夹 test  里有一个叫 a.txt 的文件。而文件夹 test my folder 里有名字分别为 a.txt b.txt 和 d.bin 的3个文件。</p><h1 id="3-显示"><a href="#3-显示" class="headerlink" title="3. 显示"></a>3. 显示</h1><p>先看一下 <strong>echo、@、pause、&gt;、&gt;&gt;、title 、rem</strong> 这几个命令或符号的用法。</p>]]></content>
      
      
      <categories>
          
          <category> 批处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-git入门</title>
      <link href="/2022/02/09/02-git/"/>
      <url>/2022/02/09/02-git/</url>
      
        <content type="html"><![CDATA[<h1 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1.版本控制"></a>1.版本控制</h1><blockquote><p>什么是版本控制</p></blockquote><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历</p><p>史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li><p>实现跨区域多人协同开发</p></li><li><p>追踪和记载一个或者多个文件的历史记录</p></li><li><p>组织和保护你的源代码和文档</p></li><li><p>统计工作量</p></li><li><p>并行开发、提高开发效率</p></li><li><p>跟踪记录整个软件的开发过程</p></li><li><p>减轻开发人员的负担，节省时间，同时降低人为错误</p></li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软</p><p>件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全</p><p>性，以及软件的整合等问题。</p><p>多人开发必须使用版本控制,否则代价会比较大!</p><blockquote><p>常见的版本控制工具</p></blockquote><p>我们学习的东西一定要是最新的</p><p><strong>Git</strong></p><p><strong>SVN</strong>（Subversion）</p><p><strong>CVS</strong>（Concurrent Versions System）</p><p><strong>VSS</strong>（Micorosoft Visual SourceSafe）</p><p><strong>TFS</strong>（</p><p>Team Foundation Server）</p><p>Visual Studio Online</p><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、</p><p>Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在</p><p>影响力最大且使用最广泛的是Git与SVN</p><blockquote><p>版本控制分类</p></blockquote><p><strong>1.本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS</p><p><strong>2、集中版本控制</strong></p><p>有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看</p><p>不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器</p><p>上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：</p><p>SVN、CVS、VSS</p><p><strong>3、分布式版本控制</strong></p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地</p><p>提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数</p><p>据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><blockquote><p>Git与SVN最主要区别</p></blockquote><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，</p><p>所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服</p><p>务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-02-09_10-50-00.png" alt="Snipaste_2022-02-09_10-50-00"></p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要</p><p>联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也</p><p>在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改</p><p>了。</p><p>Git是目前世界上最先进的分布式版本控制系统。</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-02-09_10-49-30.png" alt="Snipaste_2022-02-09_10-49-30"></p><h1 id="Git环境配置"><a href="#Git环境配置" class="headerlink" title="Git环境配置"></a>Git环境配置</h1><blockquote><p>软件下载</p></blockquote><p>打开 [git官网] <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p><p>所有下载慢的软件都可以这样</p><p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><blockquote><p>启动git</p></blockquote><p>Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多</p><p>Git CMD：Windows风格的命令行</p><p>Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><blockquote><p>基本的Linux命令学习</p></blockquote><p>1）、cd : 改变目录。</p><p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p><p>3）、pwd : 显示当前所在的目录路径。</p><p>4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p><p>5）、touch : 新建一个文件如 touch index.js 就会在当前目录下新建一个index.js文件。</p><p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p><p>7）、mkdir:  新建一个目录,就是新建一个文件夹。</p><p>8）、rm -r :  删除一个文件夹, rm -r src 删除src目录</p><p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,</p><p>必须保证文件和目标文件夹在同一目录下。</p><p>10）、reset 重新初始化终端/清屏。</p><p>11）、clear 清屏。</p><p>12）、history 查看命令历史。</p><p>13）、help 帮助。</p><p>14）、exit 退出。</p><p>15）、#表示注释</p><blockquote><p>git配置</p></blockquote><p>查看配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊Java这条路(狂神说)</title>
      <link href="/2022/02/03/14-%E8%81%8A%E8%81%8AJava%E8%BF%99%E6%9D%A1%E8%B7%AF-%E7%8B%82%E7%A5%9E%E8%AF%B4/"/>
      <url>/2022/02/03/14-%E8%81%8A%E8%81%8AJava%E8%BF%99%E6%9D%A1%E8%B7%AF-%E7%8B%82%E7%A5%9E%E8%AF%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊Java这条路"><a href="#聊聊Java这条路" class="headerlink" title="聊聊Java这条路"></a>聊聊Java这条路</h1><p><img src="https://raw.githubusercontent.com/liqincoding/img/master/1.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java SE</title>
      <link href="/2022/02/02/04-Java%20SE/"/>
      <url>/2022/02/02/04-Java%20SE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1. 运算符"></a>1. 运算符</h1><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_12-10-21.png" alt="Snipaste_2022-01-29_12-10-21"></p><p><em>ctrl+d:复制当前行到下一行</em></p><p><img src="C:/Users/secqin/Desktop/Snipaste_2022-01-29_14-42-28.png" alt="Snipaste_2022-01-29_14-42-28"></p><p>cast:转换</p><p><strong>自动升为混合运算的最高优先级</strong></p><h2 id="1-1-自增自减运算符-一元运算符"><a href="#1-1-自增自减运算符-一元运算符" class="headerlink" title="1.1 自增自减运算符(一元运算符)"></a>1.1 自增自减运算符(一元运算符)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a++;</span><br><span class="line"><span class="keyword">int</span> c == ++a</span><br></pre></td></tr></table></figure><blockquote><p>5</p><p>3</p><p>5</p></blockquote><h3 id="1-2-幂运算"><a href="#1-2-幂运算" class="headerlink" title="1.2 幂运算"></a>1.2 幂运算</h3><p>2^3:java不能这样写</p><p>很多运算需要工具类来操作</p><p>math类厉害的一批</p><p>Math.pow(2,3);这是java的正确表述</p><h3 id="1-3-逻辑运算符"><a href="#1-3-逻辑运算符" class="headerlink" title="1.3 逻辑运算符"></a>1.3 逻辑运算符</h3><p>&amp;&amp;                             ||                              !</p><p>短路运算&amp;&amp;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">boolean</span> d = (c&lt;<span class="number">4</span>)&amp;&amp;(c++&lt;<span class="number">4</span>);</span><br><span class="line">System.out.println(d);</span><br><span class="line">System.out.println(c);</span><br></pre></td></tr></table></figure><blockquote><p>false</p><p>5</p></blockquote><h3 id="1-4-位运算"><a href="#1-4-位运算" class="headerlink" title="1.4 位运算"></a>1.4 位运算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">00111100</span>;</span><br><span class="line">B = <span class="number">00001101</span>;</span><br><span class="line">A&amp;B</span><br><span class="line">A|B</span><br><span class="line">A^B <span class="comment">// 异或,相同为0,不同为1</span></span><br><span class="line">~B</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">2</span>&lt;&lt;<span class="number">3</span>);<span class="comment">//16</span></span><br></pre></td></tr></table></figure><p>&lt;&lt; (左移)*2;    &gt;&gt;(右移)/2;</p><h3 id="1-5-条件运算符"><a href="#1-5-条件运算符" class="headerlink" title="1.5 条件运算符"></a>1.5 条件运算符</h3><p><strong>x?y:z</strong></p><p>如果x==true则结果为y,否者结果为z</p><h3 id="1-6-字符串连接符"><a href="#1-6-字符串连接符" class="headerlink" title="1.6 字符串连接符"></a>1.6 字符串连接符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+a+b);</span><br><span class="line">System.out.println(a+b+<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>1020</p><p>30</p></blockquote><h3 id="1-7-运算符优先级"><a href="#1-7-运算符优先级" class="headerlink" title="1.7 运算符优先级"></a>1.7 运算符优先级</h3><p>不用刻意记忆,多用一些括号</p><h1 id="2-常量-变量-作用域"><a href="#2-常量-变量-作用域" class="headerlink" title="2. 常量,变量,作用域"></a>2. 常量,变量,作用域</h1><h2 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h2><p>变量是什么:可以变化的量</p><p>java是一种强类型语言,每个变量都必须声明其类型(基本+引用)</p><p>Java变是程序中最基本的存储单元,其要素包括变量名,变量类型和<strong>作用域</strong></p><p>注意:</p><p>1.变量名必须是合法标识符</p><p>2.;结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int a,b,c;</span></span><br><span class="line"><span class="comment">//int a=1,b=2,c=3;可以一行,但不提倡,可读性</span></span><br><span class="line">String name = <span class="string">&quot;qingjiang&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>变量作用域</strong></p><p>类变量</p><p>实例变量</p><p>局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性:变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    类变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> salary = <span class="number">100000</span>;</span><br><span class="line">    <span class="comment">//实例变量:从属于对象;如果不自行初始化,就是这个类型的默认值0 0.0</span></span><br><span class="line">    <span class="comment">//布尔值:默认是false</span></span><br><span class="line">    <span class="comment">//除了基本类型,其余默认值都是null</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//局部变量:必须声明和初始化值</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">//变量类型  变量名字</span></span><br><span class="line">        test01 test01 = <span class="keyword">new</span> test01();</span><br><span class="line">        System.out.println(test01.age);</span><br><span class="line">        System.out.println(salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-常量"><a href="#2-2-常量" class="headerlink" title="2.2 常量"></a>2.2 常量</h2><p>初始化后不能改变值 final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI =<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> PI2 = <span class="number">3.15</span>;</span><br><span class="line">    <span class="comment">//修饰符,不存在先后顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(PI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3变量的命名规范"><a href="#2-3变量的命名规范" class="headerlink" title="2.3变量的命名规范"></a>2.3变量的命名规范</h2><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_11-53-25.png" alt="Snipaste_2022-01-29_11-53-25"></p><h1 id="3-包机制"><a href="#3-包机制" class="headerlink" title="3.包机制"></a>3.包机制</h1><p>包的本质是文件夹</p><p>package开头</p><p>import:导入一个包</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_15-14-59.png" alt="Snipaste_2022-01-29_15-14-59"></p><h1 id="4-用户交互scanner"><a href="#4-用户交互scanner" class="headerlink" title="4.用户交互scanner"></a>4.用户交互scanner</h1><h2 id="4-1-Scanner对象"><a href="#4-1-Scanner对象" class="headerlink" title="4.1 Scanner对象"></a>4.1 Scanner对象</h2><p>java.util.Scanner:获得用户的输入</p><p>Scanner s = new Scanner(System.in);</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_15-23-47.png" alt="Snipaste_2022-01-30_15-23-47"></p><h2 id="4-2-代码"><a href="#4-2-代码" class="headerlink" title="4.2 代码"></a>4.2 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用next方式接收:&quot;</span>);</span><br><span class="line"><span class="comment">//        判断用户有没有输入字符串</span></span><br><span class="line">        <span class="keyword">if</span>(scanner.hasNext()==<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//使用next方式接收用户输入</span></span><br><span class="line">            String str = scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;输出的内容为:&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-next和nextLine的区别"><a href="#4-3-next和nextLine的区别" class="headerlink" title="4.3 next和nextLine的区别"></a>4.3 next和nextLine的区别</h2><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_15-31-26.png" alt="Snipaste_2022-01-30_15-31-26"></p><h2 id="4-4-判断输入是否是整数-小数"><a href="#4-4-判断输入是否是整数-小数" class="headerlink" title="4.4 判断输入是否是整数(小数)"></a>4.4 判断输入是否是整数(小数)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入整数:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(scanner.hasNextInt())&#123;</span><br><span class="line">    i = scanner.nextInt();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;输入的不是整数数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入小数:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(scanner.hasNextFloat())&#123;</span><br><span class="line">    f = scanner.nextFloat();</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;输入的不是小数数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-选择结构"><a href="#5-选择结构" class="headerlink" title="5. 选择结构"></a>5. 选择结构</h1><h2 id="5-1-if"><a href="#5-1-if" class="headerlink" title="5.1 if"></a>5.1 if</h2><p>if{}else if{}else if{}else{}</p><h2 id="5-2-switch"><a href="#5-2-switch" class="headerlink" title="5.2 switch"></a>5.2 switch</h2><h3 id="5-2-1case穿透"><a href="#5-2-1case穿透" class="headerlink" title="5.2.1case穿透"></a>5.2.1case穿透</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;挂科&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="5-2-2-switch注意点"><a href="#5-2-2-switch注意点" class="headerlink" title="5.2.2 switch注意点"></a>5.2.2 switch注意点</h3><p><code>break;</code>全部加上</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_16-11-51.png" alt="Snipaste_2022-01-30_16-11-51"></p><p>字符的本质还是数字</p><p>java—-class(字节码文件) —反编译(IDEA)<img src="C:/Users/secqin/Desktop/Snipaste_2022-01-30_16-16-38.png" alt="Snipaste_2022-01-30_16-16-38"></p><h2 id="5-3-怎么看反编译文件"><a href="#5-3-怎么看反编译文件" class="headerlink" title="5.3 怎么看反编译文件?"></a>5.3 怎么看反编译文件?</h2><p>IDEA里面打开项目结构</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_16-19-19.png" alt="Snipaste_2022-01-30_16-19-19"></p><p>反编译文件和自己写的代码对比</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_16-20-48.png" alt="Snipaste_2022-01-30_16-20-48"></p><h1 id="6-java数据类型讲解"><a href="#6-java数据类型讲解" class="headerlink" title="6. java数据类型讲解"></a>6. java数据类型讲解</h1><h2 id="6-1-数据类型"><a href="#6-1-数据类型" class="headerlink" title="6.1 数据类型"></a>6.1 数据类型</h2><p><strong>强类型语言</strong></p><p>要求变量使用要严格符合规定,所有变量必须先定义后才能使用</p><p><strong>弱类型语言</strong></p><p><strong>Java数据类型分为两大类</strong></p><p>基本类型</p><p>引用类型</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_09-44-15.png" alt="Snipaste_2022-01-29_09-44-15"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> num1 = <span class="number">30L</span>;</span><br><span class="line"><span class="keyword">float</span> num3 = <span class="number">3.14F</span></span><br></pre></td></tr></table></figure><p>String不是关键字,是类</p><p>String在idea里面不会报蓝,关键字在idea里面会报蓝</p><p>Integer:int对应的类</p><p>Byte:byte对应的类</p><p>什么是字节?</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_09-54-04.png" alt="Snipaste_2022-01-29_09-54-04"></p><h2 id="6-2-数据类型拓展"><a href="#6-2-数据类型拓展" class="headerlink" title="6.2 数据类型拓展"></a>6.2 数据类型拓展</h2><h3 id="6-2-1-整数拓展"><a href="#6-2-1-整数拓展" class="headerlink" title="6.2.1 整数拓展"></a>6.2.1 整数拓展</h3><p>表示:二进制0b     十进制    八进制0         十六进制0x</p><p>int i = 10;</p><p>int i2 = 010; //八进制0</p><p>int i3 = 0x10; //十六进制0x 0<del>9 A</del>F</p><p>sout打印的都是十进制</p><h3 id="6-2-2-浮点数拓展"><a href="#6-2-2-浮点数拓展" class="headerlink" title="6.2.2 浮点数拓展"></a>6.2.2 浮点数拓展</h3><p>float:</p><p>double:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">0.1f</span>;  <span class="comment">//0.1</span></span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">1.0</span>/<span class="number">10</span>;  <span class="comment">//0.1</span></span><br><span class="line">        System.out.println(f == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">12412414143242342234234f</span>;</span><br><span class="line"><span class="keyword">double</span> d = f+<span class="number">1</span>;  </span><br><span class="line">System.out.println(f == d);</span><br></pre></td></tr></table></figure><p>输出:true</p><p>浮点数:float 有限   离散   舍入误差     大约     接近但不等于</p><p>double</p><p>最好完全使用浮点数进行比较</p><p>银行业务:</p><p>BigDecimal</p><h3 id="6-2-3-字符拓展"><a href="#6-2-3-字符拓展" class="headerlink" title="6.2.3 字符拓展"></a>6.2.3 字符拓展</h3><p>char c1 = ‘a’;</p><p>char c2 = ‘中’</p><p>//所有的字符本质还是数字</p><p>//编码     Unicode     2字节    0-65535    Excel    2^16 = 65536</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;\u0061&#x27;</span>;</span><br><span class="line">System.out.println(c3);</span><br></pre></td></tr></table></figure><h3 id="6-2-4-转义字符"><a href="#6-2-4-转义字符" class="headerlink" title="6.2.4 转义字符"></a>6.2.4 转义字符</h3><p>\t:制表符</p><p>\n:换行</p><h3 id="6-2-5-问题"><a href="#6-2-5-问题" class="headerlink" title="6.2.5 问题"></a>6.2.5 问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sa = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String sb = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(sa == sb);</span><br><span class="line">String sc = <span class="string">&quot;he&quot;</span>;</span><br><span class="line">String sd = <span class="string">&quot;he&quot;</span>;</span><br><span class="line">System.out.println(sc==sd);</span><br></pre></td></tr></table></figure><p>Less is more!代码要精简易读!</p><h2 id="6-3-类型转换"><a href="#6-3-类型转换" class="headerlink" title="6.3 类型转换"></a>6.3 类型转换</h2><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_10-43-48.png" alt="Snipaste_2022-01-29_10-43-48"></p><p>double优先级最高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>输出(内存溢出):</p><p>-128</p><p>128</p><p>//强制转换:(类型)变量名</p><p>高-&gt;低:强制类型转换</p><p>低-&gt;高:自动类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">128</span>;</span><br><span class="line"><span class="keyword">double</span> b =i;</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>注意点:</p><p>不能对布尔值进行转换</p><p>不能把对象类型转换为不相干的类型</p><p>在把高容量转到低容量的时候,强制转换</p><p>转换的时候可能存在内存溢出,或者精度问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(((<span class="keyword">int</span>)<span class="number">23.7</span>));</span><br><span class="line">System.out.println((<span class="keyword">int</span>)-<span class="number">45.89f</span>);</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> d = c+<span class="number">1</span>;</span><br><span class="line">System.out.println(d);</span><br><span class="line">System.out.println((<span class="keyword">char</span>)d);</span><br></pre></td></tr></table></figure><p>jdk7的新特性,数字之间可以用下划线分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> money=<span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="keyword">int</span> year = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> total = money*year;</span><br><span class="line">System.out.println(total);  <span class="comment">//-1474836480</span></span><br><span class="line"><span class="keyword">long</span> total2 = money*year; <span class="comment">//默认是int,转换的时候已经出问题了</span></span><br><span class="line"><span class="keyword">long</span> total3 = money*((<span class="keyword">long</span>)year); <span class="comment">//先把一个数字转换为long</span></span><br><span class="line">System.out.println(total3);</span><br><span class="line"><span class="comment">//L,l小写可能看为1</span></span><br></pre></td></tr></table></figure><h1 id="7-数组"><a href="#7-数组" class="headerlink" title="7. 数组"></a>7. 数组</h1><h2 id="7-1-一维数组"><a href="#7-1-一维数组" class="headerlink" title="7.1 一维数组"></a>7.1 一维数组</h2><h3 id="7-1-1-数组定义"><a href="#7-1-1-数组定义" class="headerlink" title="7.1.1 数组定义"></a>7.1.1 数组定义</h3><p>int[] nums;</p><p>int nums[];</p><p>nums = new int[10];//这里面可以存放十个int类型的数字</p><h3 id="7-1-2-开辟一个空间"><a href="#7-1-2-开辟一个空间" class="headerlink" title="7.1.2 开辟一个空间"></a>7.1.2 开辟一个空间</h3><p>nums = new int[10];</p><h3 id="7-1-3-给数组元素赋值"><a href="#7-1-3-给数组元素赋值" class="headerlink" title="7.1.3 给数组元素赋值"></a>7.1.3 给数组元素赋值</h3><p>没有赋值默认值是0</p><h3 id="7-1-4-通过下标去取"><a href="#7-1-4-通过下标去取" class="headerlink" title="7.1.4 通过下标去取"></a>7.1.4 通过下标去取</h3><p>num[0]</p><h3 id="7-1-5-计算所有元素的和"><a href="#7-1-5-计算所有元素的和" class="headerlink" title="7.1.5 计算所有元素的和"></a>7.1.5 计算所有元素的和</h3><p>arrays.Length //计算数组长度</p><p>数组的四个基本特点</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_17-20-53.png" alt="Snipaste_2022-01-30_17-20-53"></p><h2 id="7-2-内存"><a href="#7-2-内存" class="headerlink" title="7.2 内存"></a>7.2 内存</h2><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_17-21-58.png" alt="Snipaste_2022-01-30_17-21-58"></p><p>声明数组</p><p>int[] array = null;</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_17-25-19.png" alt="Snipaste_2022-01-30_17-25-19"></p><p>创建数组</p><p>array = new int[10]; //默认初始化</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_17-35-01.png" alt="Snipaste_2022-01-30_17-35-01"></p><p>3.给数组元素中赋值</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_17-27-39.png" alt="Snipaste_2022-01-30_17-27-39"></p><h2 id="7-3-数组越界"><a href="#7-3-数组越界" class="headerlink" title="7.3 数组越界"></a>7.3 数组越界</h2><blockquote><p>java.lang.ArrayIndexOutOfBoundsException</p></blockquote><h2 id="7-4-数组三种初始化方式"><a href="#7-4-数组三种初始化方式" class="headerlink" title="7.4 数组三种初始化方式"></a>7.4 数组三种初始化方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态初始化:创建+赋值</span></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//动态初始化:包含默认初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">19</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_17-33-15.png" alt="Snipaste_2022-01-30_17-33-15"></p><p>没有被初始化的空间默认值都是0;</p><h2 id="7-5-下标越界"><a href="#7-5-下标越界" class="headerlink" title="7.5 下标越界"></a>7.5 下标越界</h2><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_17-38-37.png" alt="Snipaste_2022-01-30_17-38-37"></p><h2 id="7-6-数组的使用"><a href="#7-6-数组的使用" class="headerlink" title="7.6 数组的使用"></a>7.6 数组的使用</h2><h3 id="7-6-1-for循环"><a href="#7-6-1-for循环" class="headerlink" title="7.6.1 for循环"></a>7.6.1 for循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印全部的数组元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-2-增强型for循环-for-each循环"><a href="#7-6-2-增强型for循环-for-each循环" class="headerlink" title="7.6.2 增强型for循环(for-each循环)"></a>7.6.2 增强型for循环(for-each循环)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强型for循环,没有下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-7-多维数组"><a href="#7-7-多维数组" class="headerlink" title="7.7 多维数组"></a>7.7 多维数组</h2><h2 id="7-8-Arrays类"><a href="#7-8-Arrays类" class="headerlink" title="7.8 Arrays类"></a>7.8 Arrays类</h2><h2 id="7-9-稀疏数组"><a href="#7-9-稀疏数组" class="headerlink" title="7.9 稀疏数组"></a>7.9 稀疏数组</h2><h1 id="8-方法"><a href="#8-方法" class="headerlink" title="8. 方法"></a>8. 方法</h1><h2 id="8-1-方法的组成"><a href="#8-1-方法的组成" class="headerlink" title="8.1 方法的组成"></a>8.1 方法的组成</h2><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_16-38-23.png" alt="Snipaste_2022-01-30_16-38-23"></p><p>return 可以终止方法</p><h2 id="8-2-命令行传参"><a href="#8-2-命令行传参" class="headerlink" title="8.2 命令行传参"></a>8.2 命令行传参</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;args[&quot;</span>+i+<span class="string">&quot;]:&quot;</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_16-57-47.png" alt="Snipaste_2022-01-30_16-57-47"></p><h2 id="8-3-可变参数"><a href="#8-3-可变参数" class="headerlink" title="8.3 可变参数"></a>8.3 可变参数</h2><p>不定项参数</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_17-00-17.png" alt="Snipaste_2022-01-30_17-00-17"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test01 t1 = <span class="keyword">new</span> test01();</span><br><span class="line">        t1.test(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span>... i)</span></span>&#123;</span><br><span class="line">        System.out.println(i[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-什么是面向对象编程"><a href="#9-什么是面向对象编程" class="headerlink" title="9.什么是面向对象编程"></a>9.什么是面向对象编程</h1><h2 id="9-1-OOP-面向对象编程"><a href="#9-1-OOP-面向对象编程" class="headerlink" title="9.1 OOP(面向对象编程)"></a>9.1 OOP(面向对象编程)</h2><p>一个项目应该只存在一个main方法</p><p>以类的方式组织代码</p><p>以对象的方式封装数据</p><h2 id="9-2-构造器"><a href="#9-2-构造器" class="headerlink" title="9.2 构造器"></a>9.2 构造器</h2><p>也叫构造方法</p><blockquote><p>test1.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Man man = <span class="keyword">new</span> Man();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Man.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下反编译的文件(out里面的.class文件)</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-02-02_16-52-24.png" alt="Snipaste_2022-02-02_16-52-24"></p><p>一个类即使什么都不写,它也会存在一个方法,构造方法</p><p>显示的定义构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.使用new关键字,本质是在调用构造器</p><p>干掉无参:定义有参构造器</p><p><strong>一旦定义了有参构造,无参就必须显示定义</strong></p><p><em>alt+insert可以快速无参和有参构造</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点:</p><p>构造器:1.和类名相同</p><p>2.没有返回值</p><p>作用:</p><p>new的本质是调用构造方法</p><p>2.初始化对象的值</p><p>3.定了有参后,一定要显示调用无参</p><h2 id="9-3-内存分析"><a href="#9-3-内存分析" class="headerlink" title="9.3 内存分析"></a>9.3 内存分析</h2><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-02-02_19-09-57.png" alt="Snipaste_2022-02-02_19-09-57"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-02-02_19-10-48.png" alt="Snipaste_2022-02-02_19-10-48"></p><p>对象是通过引用来操作的:栈-&gt;堆</p><p>类:</p><p>静态的属性   属性</p><p>动态的行为   方法</p><h1 id="10-封装"><a href="#10-封装" class="headerlink" title="10. 封装"></a>10. 封装</h1><p><strong>高内聚,低耦合</strong></p><p>该漏的漏,该藏的藏</p><p>属性私有</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-02-02_19-23-23.png" alt="Snipaste_2022-02-02_19-23-23"></p><p>要提供一些操作这个数据的方法</p><p>属性私有,get/set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> String name;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><em>alt+insert</em></p><p>提高程序的安全性,保护数据</p><p>隐藏代码的实现细节</p><p>统一接口</p><p>系统可维护性增加了</p><h1 id="11-继承"><a href="#11-继承" class="headerlink" title="11. 继承"></a>11. 继承</h1><p>JAVA中类只有单继承,没有多继承</p><p>但可以简介继承多个(爷爷辈)</p><p>子类(派生类)和父类(基类)</p><p>extends</p><p>继承和组合</p><blockquote><p>public class Student extends Man</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    Man man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure><p>子类可以继承父类的所有方法</p><p>四个修饰符:</p><p>public</p><p>protected</p><p>default</p><p>private</p><p><em>ctrl+h</em>:打开类树</p><p>在Java中所有的类都默认直接或者间接继承Object类</p><p>一个儿子只能有一个爸爸,一个爸爸可以有多个儿子</p><h1 id="12-Super"><a href="#12-Super" class="headerlink" title="12. Super"></a>12. Super</h1><p>调父类的方法或者属性</p><p>私有的东西无法被继承</p><p><strong>隐藏代码,先调父类的无参构造,而且父类的构造器必须在第一行,如果不是第一行就会报错</strong></p><p><strong>父类和子类的构造函数有点意思,重点和难点</strong></p><p>注意点:</p><p>1.super调用父类的构造方法,必须在构造方法的第一个</p><p>2.super必须只能出现在子类的方法或者构造方法中</p><p>3.super和this不能同时调用构造方法</p><p>this:</p><p>代表的对象不同</p><p>this:本身调用者这个对象</p><p>super:代表父类对象的应用</p><p>前提</p><p>this:没有继承也可以使用</p><p>super:只能在继承条件下可以使用</p><p>构造方法</p><p>this();本类的构造</p><p>super():父类的构造</p><h1 id="13-方法的重写"><a href="#13-方法的重写" class="headerlink" title="13. 方法的重写"></a>13. 方法的重写</h1><p><strong>重写都是方法的重写,和属性无关</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">a.test();</span><br><span class="line">B b = <span class="keyword">new</span> A();</span><br><span class="line">b.test();</span><br></pre></td></tr></table></figure><p>@Override 重写</p><p>静态方法和非静态方法区别很大</p><p>重写与静态方法无关,只和非静态有关</p><p>重写只能public,并且不能是静态方法,和重载不一样</p><p><strong>总结</strong></p><p>重写:</p><ul><li>需要有继承关系</li><li>子类重写父类方法</li><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符:范围可以扩大,但是不能缩小     public-&gt;protected-&gt;default-&gt;private</li><li>抛出的异常:范围可以被缩小,但不能扩大</li><li>重写,子类的方法和父类必须要一致:方法体不同!</li></ul><p>为什么需要重写?</p><ol><li><p>父类的功能子类不一定需要,或者不一定满足!</p><p>快捷键:<em>Alt + Insert        :     override</em></p></li></ol><h1 id="14-多态"><a href="#14-多态" class="headerlink" title="14. 多态"></a>14. 多态</h1><p>动态编译类型:可扩展性更强</p><blockquote><p>Student.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;liyixin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;est&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Person.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;liqin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>test.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//        一个对象的实际类型是确定的</span></span><br><span class="line"><span class="comment">//        可以指向的引用类型就不确定了</span></span><br><span class="line"><span class="comment">//        可以指向的引用类型就不确定了:父类的引用指向子类</span></span><br><span class="line">        Person s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        Object s3 = <span class="keyword">new</span> Student();</span><br><span class="line">        s2.run(); <span class="comment">//子类重写了父类的方法,执行子类的方法</span></span><br><span class="line"><span class="comment">//        对象能执行哪些方法,主要看对象左边的类型,和右边关系不大</span></span><br><span class="line"><span class="comment">//        Student 能调用的方法都是自己的或者继承父类的,</span></span><br><span class="line"><span class="comment">//        person 父类型,可以调用子类,但是不能调用子类独有的方法</span></span><br><span class="line">        s1.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Student) s2).eat();</span><br></pre></td></tr></table></figure><p>如果强转可以用</p><p>多态注意事项:</p><ol><li>多态的方法的多态,属性无多态</li><li>父类和子类必须有联系,否则类型转换异常(String)ClassCastException</li><li>存在条件:继承关系,方法需要重写,父类的引用,指向子类对象! <strong>父亲 f1 = new 儿子()</strong></li></ol><p>三种方法不能重写</p><ol><li>static方法属于类,不属于任何一个实例</li><li>final 常量池</li><li>private 私有方法</li></ol><h1 id="15-instanceof和类型转换"><a href="#15-instanceof和类型转换" class="headerlink" title="15. instanceof和类型转换"></a>15. instanceof和类型转换</h1><p>判断一个对象是什么类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Object &gt; String</span></span><br><span class="line"><span class="comment">//        Object &gt; Person &gt; Teacher</span></span><br><span class="line"><span class="comment">//        Object &gt; Person &gt; Student</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Student); <span class="comment">//T</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Person); <span class="comment">//T</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Teacher);<span class="comment">//F</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> Object);<span class="comment">//T</span></span><br><span class="line">        System.out.println(object <span class="keyword">instanceof</span> String);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Student); <span class="comment">//t</span></span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Person); <span class="comment">//t</span></span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Teacher);<span class="comment">//F</span></span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> Object);<span class="comment">//T</span></span><br><span class="line"><span class="comment">//        System.out.println(person instanceof String);//F 编译就报错</span></span><br><span class="line"></span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Student); <span class="comment">//t</span></span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Person); <span class="comment">//t</span></span><br><span class="line"><span class="comment">//        System.out.println(student instanceof Teacher); // 编译就报错</span></span><br><span class="line">        System.out.println(student <span class="keyword">instanceof</span> Object);<span class="comment">//T</span></span><br><span class="line"><span class="comment">//        System.out.println(person instanceof String);//F 编译就报错</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>X instanceof Y</strong>:X与Y见是否存在父子关系,决定是否编译可以通过 和接口对比理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//类型之间的转换,基本类型的转换 高低 父类与子类,父类代表高</span></span><br><span class="line"><span class="comment">//        高            低</span></span><br><span class="line">        Person obj = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//将这个对转换为student类型,我们就可以使用student类型的方法了</span></span><br><span class="line">        ((Student) obj).go();</span><br><span class="line">        Student student = (Student) obj;</span><br><span class="line">        student.go();</span><br><span class="line"><span class="comment">//        子类转父类可能丢失自己的一些方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结:</p><ol><li>父类引用指向子类的对象</li><li>把子类转换为父类,向上转型,不用强制转换</li><li>把父类转换为子类,向下转型:强制转换</li><li>方便方法的调用,减少重复的代码!科有效提升代码利用率</li></ol><p>封装,继承,多态! 抽象类,接口</p><h1 id="16-static"><a href="#16-static" class="headerlink" title="16.static"></a>16.static</h1><p>第一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age; <span class="comment">//静态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(Student.age);</span><br><span class="line">        System.out.println(student.age);</span><br><span class="line">        go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//代码块(匿名代码块)</span></span><br><span class="line">        <span class="comment">//赋初始值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态导入包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br></pre></td></tr></table></figure><p>被final定义,直接断子绝孙,不能被继承</p><h1 id="17-抽象类"><a href="#17-抽象类" class="headerlink" title="17.抽象类"></a>17.抽象类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">//    约束,有人帮我们实现</span></span><br><span class="line"><span class="comment">//    抽象方法,只有方法名字,没有方法的实现</span></span><br><span class="line">    <span class="comment">//抽象类,extents:单继承,无多继承,接口可以多继承,插座</span></span><br><span class="line"><span class="comment">//    不能new这个抽象类,只能靠子类去实现他,约束</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//    一旦有抽象方法,就必须是抽象类</span></span><br><span class="line"><span class="comment">//    抽象类可以写普通方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    思考题? new存在构造器么?</span></span><br><span class="line"><span class="comment">//    存在的意义  抽象出来  提高开发效率</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考</p></blockquote><p>new抽象类存在构造器么?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类的所有方法,继承了他的子类,都必须要实现他的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-接口-OO"><a href="#18-接口-OO" class="headerlink" title="18.接口(OO)"></a>18.接口(OO)</h1><p>接口,只有规范!自己无法写方法,专业的约束,约束和实现分离,面向接口的编程</p><p>接口的本质是契约,接口的精髓是对对象的抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">//    抽象的思维锻炼~ Java,架构师</span></span><br><span class="line"><span class="comment">//    接口中所有的定义其实都是抽象的public</span></span><br><span class="line"><span class="comment">//    接口都需要有实现类</span></span><br><span class="line"><span class="comment">//    接口中定义的属性,都是常量public static final ~</span></span><br><span class="line">    <span class="keyword">int</span> AGE = <span class="number">99</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类的所有方法,继承了他的子类,都必须要实现他的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">Student</span></span>&#123; <span class="comment">//利用接口实现多继承,接口只有方法的定义,</span></span><br><span class="line"><span class="comment">//    实现了接口的类,就需要重写接口的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用:</strong></p><ol><li>约束</li><li>定义一些方法,让不同的人实现~</li><li>public abstract</li><li>public static final</li><li>接口不能被实例化,接口中没有构造方法</li><li>可以实现多个接口</li><li>必须要重写接口中的方法</li></ol><h1 id="19-内部类"><a href="#19-内部类" class="headerlink" title="19.内部类"></a>19.内部类</h1><ol><li>成员内部类</li><li>静态内部类’</li><li>局部内部类</li><li>匿名内部类’</li></ol><h1 id="20-异常"><a href="#20-异常" class="headerlink" title="20.异常"></a>20.异常</h1><h2 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1.什么是异常"></a>1.什么是异常</h2>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>破解软件合集</title>
      <link href="/2022/01/30/15-%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6%E5%90%88%E9%9B%86/"/>
      <url>/2022/01/30/15-%E7%A0%B4%E8%A7%A3%E8%BD%AF%E4%BB%B6%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h2 id="Navicat-15"><a href="#Navicat-15" class="headerlink" title="Navicat 15"></a>Navicat 15</h2><p>链接：<a href="https://pan.baidu.com/s/1wzoYWUvdzjACbhade_GYPA">https://pan.baidu.com/s/1wzoYWUvdzjACbhade_GYPA</a><br>提取码：1234 </p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>链接：<a href="https://pan.baidu.com/s/1ditBXPwn7K_QaKpyeK8Akg">https://pan.baidu.com/s/1ditBXPwn7K_QaKpyeK8Akg</a><br>提取码：1234 </p><h2 id="xshell"><a href="#xshell" class="headerlink" title="xshell"></a>xshell</h2><p>链接：<a href="https://pan.baidu.com/s/13_hF4doPZdIYHHEj1TwCVA">https://pan.baidu.com/s/13_hF4doPZdIYHHEj1TwCVA</a><br>提取码：1234 </p><h2 id="xmind"><a href="#xmind" class="headerlink" title="xmind"></a>xmind</h2><p>链接：<a href="https://pan.baidu.com/s/1ZQgMMAq878HRXMtczw1c3g">https://pan.baidu.com/s/1ZQgMMAq878HRXMtczw1c3g</a><br>提取码：1234 </p><h2 id="IDEA-2021-03版本以下全破解"><a href="#IDEA-2021-03版本以下全破解" class="headerlink" title="IDEA(2021.03版本以下全破解)"></a>IDEA(2021.03版本以下全破解)</h2><p>链接：<a href="https://pan.baidu.com/s/1576LM-6vtiYFTICL2ZT4YQ">https://pan.baidu.com/s/1576LM-6vtiYFTICL2ZT4YQ</a><br>提取码：1234 </p><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="jdk1-8-0-261"><a href="#jdk1-8-0-261" class="headerlink" title="jdk1.8.0_261"></a>jdk1.8.0_261</h2><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2>]]></content>
      
      
      <categories>
          
          <category> 破解软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 破解软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos8.2上面安装java8</title>
      <link href="/2022/01/29/13-centos8-2%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85java8/"/>
      <url>/2022/01/29/13-centos8-2%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85java8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-jdk8-linux链接"><a href="#1-jdk8-linux链接" class="headerlink" title="1.jdk8(linux链接)"></a>1.jdk8(linux链接)</h1><p>链接：<a href="https://pan.baidu.com/s/1qIogUyhH8vicHgBKwKw0Uw">https://pan.baidu.com/s/1qIogUyhH8vicHgBKwKw0Uw</a><br>提取码：1234 </p>]]></content>
      
      
      <categories>
          
          <category> linux开发环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux开发环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在华为云上面安装kali</title>
      <link href="/2022/01/29/16-%E5%9C%A8%E5%8D%8E%E4%B8%BA%E4%BA%91%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85kali/"/>
      <url>/2022/01/29/16-%E5%9C%A8%E5%8D%8E%E4%B8%BA%E4%BA%91%E4%B8%8A%E9%9D%A2%E5%AE%89%E8%A3%85kali/</url>
      
        <content type="html"><![CDATA[<p>39元买了一台华为云耀云服务器1年,香的一批</p><p>第一步:检查自己的服务器在那个城市,哪个可用区</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-03-01.png" alt="Snipaste_2022-01-29_23-03-01"></p><p>然后去购买额外的磁盘(和自己的服务器在同一个城市,同一个可用区)</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-05-01.png" alt="Snipaste_2022-01-29_23-05-01"></p><p>然后来对应的服务器挂载磁盘</p><p><img src="C:/Users/secqin/Desktop/Snipaste_2022-01-29_23-06-46.png" alt="Snipaste_2022-01-29_23-06-46"></p><p>然后通过登录界面登录,然后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.163.com/kali-images/kali-2021.4a/kali-linux-2021.4a-installer-amd64.iso</span><br></pre></td></tr></table></figure><p>下载到当前目录</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-14-59.png" alt="Snipaste_2022-01-29_23-14-59"></p><p>这个速度还是很猛的,不能使用kali的官方源,官方源蜗速,用163的下载</p><p>挂载好我们添加的数据盘之后，首先执行一下<code>fdisk -l</code>看一下磁盘的情况：<img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-20-53.png" alt="Snipaste_2022-01-29_23-20-53"></p><p>突然发现我那个10GB的硬盘没有挂载上去,挂载一下硬盘<img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-27-12.png" alt="Snipaste_2022-01-29_23-27-12"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-28-07.png" alt="Snipaste_2022-01-29_23-28-07"></p><p>在这里我将把镜像写入<code>vdb</code>这块数据盘，请确保里面没有需要的数据了，所以更加建议创建一个临时的云硬盘来做这件事情。Linux 下写 ISO 是很简单的，用<code>dd</code>就可以了，非 root 的情况下别忘了<code>sudo</code>哦。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=kali-linux-2021.4a-installer-amd64.iso of=/dev/vdb</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-32-16.png" alt="Snipaste_2022-01-29_23-32-16"></p><p>接下来我们需要把安装程序跑起来，途径也是多样的，我选择直接操作 GRUB 2 的命令行。不过，先调整一下超时时间来避免来不及操作。编辑<code>/etc/default/grub</code>这个文件，将<code>GRUB_TIMEOUT</code>调得足够长，例如 60 秒。然后运行<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code>写入配置。</p><blockquote><p><strong>引导进入安装程序</strong></p></blockquote><p>这时可以<code>reboot</code>了，然后登录华为云的控制台，在对应的云主机处点击 “操作” 下的 “登录” 即可以进入网页 VNC。若之前配置无误，现在应该正处于 GRUB 菜单，看起来就像这样：<img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-35-39.png" alt="Snipaste_2022-01-29_23-35-39"></p><p>然后我们按<code>c</code>键进入命令行模式，来手动引导。现在的发行版基本都是使用 GRUB 2 了，如果还是 GRUB 的话要把下面的<code>set root=(hd1)</code>改成<code>root (hd1)</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grub&gt; set root=(hd1)</span><br><span class="line">grub&gt; chainloader +1</span><br><span class="line">grub&gt; boot</span><br></pre></td></tr></table></figure><p>进入安装目录</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-36-08.png" alt="Snipaste_2022-01-29_23-36-08"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-39-31.png" alt="Snipaste_2022-01-29_23-39-31"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-41-58.png" alt="Snipaste_2022-01-29_23-41-58"></p><p>到这一步 kali会检测安装安装光盘，这时候我们选择手动探测加载光盘，然后我们选 none</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-40-18.png" alt="Snipaste_2022-01-29_23-40-18"></p><p>注意这个地方是<code>/dev/vdb1</code></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-42-46.png" alt="Snipaste_2022-01-29_23-42-46"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-44-08.png" alt="Snipaste_2022-01-29_23-44-08"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-44-13.png" alt="Snipaste_2022-01-29_23-44-13"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-44-27.png" alt="Snipaste_2022-01-29_23-44-27"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-44-49.png" alt="Snipaste_2022-01-29_23-44-49"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-45-36.png" alt="Snipaste_2022-01-29_23-45-36"></p><p>然后回车后就可以接着安装，磁盘分区的位置我们选我们的系统盘。</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-46-04.png" alt="Snipaste_2022-01-29_23-46-04"></p><p>然后将所有文件放在同一个分区中</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-46-13.png" alt="Snipaste_2022-01-29_23-46-13"></p><p>最后结束分区设定并将修改写入磁盘</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-46-23.png" alt="Snipaste_2022-01-29_23-46-23"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-46-32.png" alt="Snipaste_2022-01-29_23-46-32"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-29_23-49-05.png" alt="Snipaste_2022-01-29_23-49-05"></p><p>下面这里安装grub启动器也是安装到第一个磁盘</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_00-00-16.png" alt="Snipaste_2022-01-30_00-00-16"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_00-00-48.png" alt="Snipaste_2022-01-30_00-00-48"></p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_00-01-51.png" alt="Snipaste_2022-01-30_00-01-51"></p><p>登录</p><p><img src="https://gitee.com/secqin/img/raw/master/img/Snipaste_2022-01-30_00-03-19.png" alt="Snipaste_2022-01-30_00-03-19"></p><blockquote><p>在腾讯云下面:提示光盘一直挂载报错。可以终止安装 进入kali安装界面的 shell 里面执行这个 mount /dev/vdb1 /cdrom  先挂载到cdrom 然后再去安装就好了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> kali_linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali_linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
